generalConcept,subConcept,lesson,subLesson,explanation,NB,img,example,prefix_text,prefix_text,code,output,codeExplanation,,
الأساسيات,أسلوب كتابة الكود,مبادئ كتابة الكود,,"في البداية عليك معرفة أن كل ما ستتعلمه في هذا الدرس عبارة عن شرح نظري لأساليب كتابة الكود.
إذاَ في هذا الدرس ستتعلم كيف تكتب كود C++ بشكل صحيح يفهمه الكمبيوتر و يفهمه أي شخص يحاول قراءة الكود الذي ستقوم أنت بكتابته مستقبلاً عند بناء تطبيقاتك الخاصة.",,,,,,,,,,
الأساسيات,أسلوب كتابة الكود,مبادئ كتابة الكود,Case Sensitivity,"لغة C++ تطبق مفهوم الـ Case Sensitivity, و هذا يعني أنها تميز بين الأحرف الكبيرة و الأحرف الصغيرة.

",,,مثال: note و Note ليسوا شيئاً واحداً.,,,,,,,
الأساسيات,أسلوب كتابة الكود,مبادئ كتابة الكود,Strictly Typed,"لغة C++ تطبق مفهوم الـ Strictly Typed, و هذا يعني أنه يجب تحديد نوع المتغير مباشرةً عند تعريفه (مثل عدد صحيح , حرف , عدد عشري , الخ..) و لا يمكن تغيير نوع البيانات المخزنة فيه لاحقاً كما هو الحال في لغة جافا C و C#, و على خلاف بعض اللغات الأخرى مثل بايثون و جافا سكريبت.
",,,,,,,,,,
الأساسيات,أسلوب كتابة الكود,مبادئ كتابة الكود,إسم الكلاس,"يفضل أن يبدأ إسم الكلاس بحرف كبير و في حال كان إسم الكلاس يتألف من أكثر من كلمة, إجعل أول  حرف من كل كلمة كبيراً.
",,,"
  أمثلة
  في حال كان إسم الكلاس يتألف من كلمة واحدة.
  class Car{ }
  
  في حال كان إسم الكلاس يتألف من أكثر من كلمة.
  class CppFirstClass{ }
  
 ",,,,,"

",,
الأساسيات,أسلوب كتابة الكود,مبادئ كتابة الكود,إسم المتغير,"إستخدم الأحرف الصغيرة عند اختيار أسماء للمتغيرات و في حال كان إسم المتغير يتألف من أكثر من كلمة إبدأ كل كلمة بحرف كبير ابتداءً من الكلمة الثانية.
",,,"
  أمثلة
  في حال كان إسم المتغير يتألف من كلمة واحدة.
  int color;
  
  في حال كان إسم المتغير يتألف من أكثر من كلمة.
  int firstCarColor;
  ",,,"
	",,,,
الأساسيات,أسلوب كتابة الكود,مبادئ كتابة الكود,إسم الدالة,"إستخدم الأحرف الصغيرة عند اختيار أسماء للدوال و في حال كان إسم الدالة يتألف من أكثر من كلمة إبدأ كل كلمة بحرف كبير ابتداءً من الكلمة الثانية.
",,,"
  أمثلة
  في حال كان إسم الدالة يتألف من كلمة واحدة.
  void color();
  
  في حال كان إسم الدالة يتألف من أكثر من كلمة.
        void changeCarColor();
  
 ",,,,,,,
الأساسيات,أسلوب كتابة الكود,مبادئ كتابة الكود,التعليقات,"نستخدم التعليقات لنضع ملاحظات حول الكود الذي كتبناه فقط, لكي لا ننسى كيف برمجنا الكود في حال أردنا مراجعته أو التعديل عليه بعد وقت طويل.
	التعليقات لا تؤثر إطلاقاً على الكود المكتوب, و في لغة C++ يوجد أسلوبين لوضع التعليقات:
تعليق على سطر واحد.
		تعليق على عدة أسطر.

",تذكر: أنت لست مجبراً على وضع تعليقات في برامجك. و لكننا ننصحك بوضع تعليقات دائماً حتى تساعدك في فهم الكود الذي كتبته.,,"
  أمثلة
  في حال كان التعليق يتألف من سطر واحد, نضع الرمز // قبل كتابة التعليق.
  // this is a one line comment    تعليق سطر واحد
  
  في حال كان التعليق يتألف من عدة أسطر, نبدأ التعليق بالرمز /* و ننهيه بالرمز */.
  /*
This is multlines comment 
هذا تعليق
يتألف من
عدة سطور
*/
",,,"		
	",,,,
الأساسيات,أسلوب كتابة الكود,الأحرف المستخدمة في وضع الأسماء,,"أي إسم نضعه لمتغير, دالة, كلاس, كائن إلخ.. يسمى identifier في البرمجة.
 في C++ كل عنصر نريد خلقه علينا إعطاءه إسم خاص, أي علينا تحديد الـ identifier له.
 إذاً يتم التمييز بين العناصر في C++ من خلال أسمائهم, أي من خلال الـ Identifiers.
",,,,,,,,,,
الأساسيات,أسلوب كتابة الكود,الأحرف المستخدمة في وضع الأسماء,قواعد إلزامية عند إعطاء الأسماء,"جميع الـ Identifiers يجب أن يبدأوا بحرف كبير بين A-Z أو حرف صغير بين a-z أو الشحطة _.
يمنع بدء الـ Identifiers برقم.
يمنع استخدام الـ Literals أي القيم true, false.
يمنع إستخدام أي كلمة من الكلمات المحجوزة ( Keywords ).
لا تنسى أن C++ تطبق مبدأ الـ Case Sensitive.
ركز على أول حرف فقط
",,,"أمثلة للأسماء التي يسمح باستخدامها: Harmash , name , _number
أمثلة للأسماء التي يمنع استخدامها: 1st , -cash , @user",,,,,,,
الأساسيات,أسلوب كتابة الكود,الكلمات المحجوزة,,"جميع الكلمات التالية محجوزة للغة C++, أي لا يمكن إستخدامها كـ Identifiers.",,,"['alignas', 'alignof', 'and', 'and_eq', 'auto', 'bitand', 'bitor', 'bool', 'break', 'case', 'catch', 'char', 'char16_t', 'char32_t', 'class', 'compl', 'const', 'constexpr', 'const_cast', 'continue', 'decltype', 'default', 'delete', 'do', 'double', 'dynamic_cast', 'else', 'enum', 'explicit', 'export', 'extern', 'false', 'float', 'for', 'friend', 'goto', 'if', 'inline', 'int', 'long', 'mutable', 'namespace', 'new', 'noexcept', 'not', 'not_eq', 'nullptr', 'operator', 'or', 'or_eq', 'private', 'protected', 'Public', 'register', 'reinterpret_cast', 'requires', 'return', 'short', 'signed', 'sizeof', 'static', 'static_assert', 'static_cast', 'struct', 'switch', 'template', 'this', 'thread_local', 'throw', 'true', 'try', 'typedef', 'typeid', 'typename', 'union', 'unsigned', 'using', 'virtual', 'void', 'volatile', 'wchar_t', 'while', 'xor', 'xor_eq']",,,,,,,
الأساسيات,أمر الطباعة cout >>,أمر الطباعة cout,,"بشكل عام, نستخدم الأمر cout لطباعة أي شيء نريد في الكونسول.
	عند إستخدام الأمر cout يجب أن تضع العامل << قبل أي شيء تريد تمريره له حتى يتم طباعته.
",,,,,,"#include <iostream>

int main()
{
    std::cout << ""Harmash.com"";
    return 0;
}
		","Harmash.com
","الأمر #include <iostream> الموجود في السطر الأول يقوم بتضمين الحزمة iostream التي تحتوي على الأوامر الأساسية التي نحتاجها في التطبيقات التي تعتبر Console Application و التي سنستخدمها في أغلب البرامج مثل أمر الطباعة cout و غيره من الأوامر و الدوال الجاهزة التي ستمر معك لاحقاً في الدورة.
		سبب وضع std:: قبل cout هو أن الأمر cout موجود فيه.
		الدالة main() التي قمنا بتعريفها ابتداءاً من السطر الثالث يجب أن يكون نوعها int لأنها تمثل نقطة البداية في البرنامج.
		وضع return 0; في السطر السادس و كآخر أمر في الدالة main() هو أمر متعارف عليه, و فكرته إرسال الرقم 0 لنظام التشغيل عند انتهاء أو إغلاق البرنامج بشكل طبيعي. هكذا سيتمكن نظام التشغيل من التفريق بين الإنهاء الطبيعي للبرنامج والإنهاء المفاجئ ( Crash ) الذي يحدث نتيجة خطأ ما.
",,
الأساسيات,أمر الطباعة cout >>,مبادئ الطباعة الأساسية,عليك مراعاة المبادئ التالية عند استخدام الأمر cout.,"لعرض رقم, ضعه كما هو.
لعرض قيمة متغير, ضعه كما هو.
لعرض حرف يجب وضعه بين ' '.
	لعرض  كلمة أو نص, يجب وضعه بين "" "".
",,,,,,,,,,
الأساسيات,أمر الطباعة cout >>,طباعة عدة أشياء دفعة واحدة بواسطة الأمر cout,,"لدمج عدة أشياء مختلفة و عرضها باستخدام الأمر cout نضع الرمز << بين كل شيئين نريد طباعتهما.
",,,,,"في المثال التالي,  قمنا بإنشاء برنامج يحتوي على متغيرين name و year.
	بعدها قمنا بعرضهما كجملة واحدة.
","#include <iostream>

int main()
{
    char *name = ""Ali"";
    int year   = 1996;

    std::cout << ""Hello my name is "" << name << "", I born in "" << year;
    return 0;
}
		","Hello my name is Ali, I born in 1996
",,,
الأساسيات,أمر الطباعة cout >>,عرض المحتوى على سطر جديد,,"عند عرض المحتوى بواسطة الأمر cout يمكنك تحديد نهاية السطر من خلال وضع العامل endl و عندها سيظهر أي شيء تطبعه بعده على سطر جديد.
	
",معلومة: endl إختصار لجملة End Line.,,,,,"#include <iostream>

int main()
{
    std::cout << ""Harmash.com"" << std::endl << ""C++ course"";
    return 0;
}
		","Harmash.com
C++ course
",سبب وضع std:: قبل العامل endl هو أن العامل endl موجود فيه.,,
الأساسيات,أمر الطباعة cout >>,أهمية الكلمة using,,"إذا أردت أن تكتب الأمرين cout و endl بشكل مباشر بدون الحاجة لأن تكتب قبلهما std::, قم بتضيمن النطاق std مرة واحدة في الملف و عندها تصبح قادر على استخدام أي شيء موجود فيه بشكل مباشر.

",لتضمين النطاق std في الملف main.cpp نكتب using namespace std; فوق الدالة main().,,,,"الآن, سنعيد نفس المثال السابق مع تضمين النطاق std بشكل مباشر.
","#include <iostream>
using namespace std;   // std هنا قمنا بتضيمن النطاق

int main()
{
    cout << ""Harmash.com"" << endl << ""C++ course"";
    return 0;
}
		","Harmash.com
C++ course
",,,
الأساسيات,أمر الطباعة cout >>,النزول على سطر جديد بواسطة الرمز \n,,"إذا أردت النزول على سطر جديد بدون الحاجة لكتابة << endl فيمكنك تمرير \n كنص.
	ملاحظة: أغلب المبرمجين يفضلون تمرير \n بدل كتابة << endl لأنها مختصرة أكثر.

",معلومة: \n إختصار لجملة New Line.,,,,"في المثال التالي قمنا بتمرير \n كنص للأمر cout من أجل النزول على سطر جديد.
","#include <iostream>
using namespace std;

int main() {
	cout << ""Harmash.com\nC++ course"";
	return 0;
}
		","Harmash.com
C++ course
",,,
الأساسيات,أمر الطباعة cout >>,النزول على سطر جديد بواسطة الرمز \n,,"هنا قمنا بإعادة المثال السابق تماماً مع كتابة أمرين cout هذه المرة.

", ملاحظة: هذا الأسلوب أسهل من ناحية القراءة و التعديل و لهذا ننصح باعتماده بدلاً من الأسلوب السابق.,,,,,"#include <iostream>
using namespace std;

int main() {
	cout << ""Harmash.com\n"";
	cout << ""C++ course"";
	return 0;
}
		","Harmash.com
C++ course
",,,
الأساسيات,أمر الطباعة cout >>,وضع عدة مسافات فارغة بواسطة الرمز \t,,"إذا أردت وضع عدة مسافات فارغة دفعة واحدة و بشكل مرتب فالأفضل أن تستخدم الرمز \t بدل وضع المسافات بنفسك.
	من الأشياء التي قد تجعلك تستخدم \t هي أنه عند طباعة عدة أسطر تجده يحاول عرضهم لك بشكل متناسق لإظهار المحتوى بشكل أسهل للقراءة.

",معلومة: \t إختصار لجملة Tab Space.,,,,"في المثال التالي قمنا بوضع الرمز \t بين الكلمات من أجل وضع مسافة تلقائية بينهم بشكل مرتب.
","#include <iostream>
using namespace std;

int main()
{
    cout << ""Name:\tAli Rabeei\n"";
    cout << ""Job:\tProgrammer"";
    return 0;
}
		","Name:   Ali Rabeei
Job:    Programmer
",,,
الأساسيات,أمر الطباعة cout >>,إصدار صوت تنبيه بواسطة الرمز \a,,"إذا أردت إصدار صوت تنبيه لجعل المستخدم ينتبه للكونسول, يمكنك ذلك بكل سهولة من خلال تمرير الرمز \a كنص للأمر cout.

",معلومة: \a إختصار لكلمة Alert.,,,,"في المثال التالي قمنا باستخدام الرمز \a لتشغيل صوت تنبيه في جهاز المستخدم.
","#include <iostream>
using namespace std;

int main()
{
    cout << ""Yes, you hear the alert :)\a"";
    return 0;
}
		","لا تنسى رفع صوت الحاسوب حتى تسمع صوت التنبيه عند التشغيل و سيظهر لك النص التالي أيضاً.
Yes, you hear the alert :)
",,,
الأساسيات,أمر الطباعة cout >>,المسافات الفارغة و ترتيب الكود,,"لغة C++ لا تتأثر بالمساحات البيضاء ( White Spaces ) مثل المسافات والأسطر الفارغة حتى انه يمكن كتابة بعض البرامج بالكامل في سطر واحد و لكن لا ننصح ابداً بذلك و يفضل ترك مسافات و أسطر فارغة حتى تكون قادر على مراجعة و استيعاب الكود بسهولة تامة عند الرجوع إليه.
",,,,,"في المثال التالي قمنا بكتابة نفس المثال السابق على سطر واحد.
	تنبيه: رغم أن الأسلوب التالي لا يوجد فيه أي مشكلة برمجياً, إلاّ أننا ننصحك بعدم إعتماد هذا الأسلوب إطلاقاً عند كتابة الكود.
","#include <iostream>
using namespace std; int main() {cout << ""Harmash.com""<<endl<<""C++ course"";return 0;}
		","Harmash.com
C++ course
",,,
الأساسيات,إدخال بيانات من المستخدم,أمر الإدخال cin,,"لجعل المستخدم قادر على إدخال بيانات في البرنامج أثناء اشتغاله نستخدم أمر الإدخال cin >>.
	الأمر cin موجود في الحزمة std و لهذا يجب ان تكتب std::cin إن لم تكن تريد تضمين الحزمة std في برنامجك.
في كل مرة تقوم فيها باستدعاء هذا الأمر يقوم المترجم بانتظارك لإدخال عدد أو كلمة واحدة من لوحة المفاتيح ( Keyboard ).
	بعد الإنتهاء من الإدخال و النقر على الزر Enter سيتم إرجاع الشيء الذي قمت بإدخاله في المكان الذي تم منه إستدعاء الأمر cin >>.
",,,,,,"#include <iostream>

using namespace std;

int main()
{
	// لتخزين المعلومات التي سيدخلها المستخدم لاحقاً age و name قمنا بتجهيز المتغيرين
	string name;
	int age;
	
	// name هنا سيطلب من المستخدم إدخال إسمه و من ثم سيتم تخزين الإسم الذي يدخله في المتغير
    cout << ""What's your name? "";
	cin >> name;
	
	// age هنا سيطلب من المستخدم إدخال عمره و من ثم سيتم تخزين الرقم الذي يدخله في المتغير
    cout << ""How old are you? "";
	cin >> age;
	
	// في الأخير قمنا بعرض المعلومات التي يدخلها المستخدم بشكل مرتب
	cout << ""Your name is "" << name << "", and your age is "" << age << "" years."";
	
    return 0;
}
		","What's your name? Mhamad
How old are you? 25
Your name is Mhamad, and your age is 25 years.
",,,
الأساسيات,إدخال بيانات من المستخدم,الفرق بين الأمر cin و الأمر cout,,"في البداية معرفة سبب تسمية الأوامر بهذه الكلمات سيسهل عليك تذكر الفرق بينهما, لذا تذكر دائماً أصلهما:
		cin يقصد بها كلمة See In و التي بدورها تستخدم لإدخال قيمة في المتغير.
		cout يقصد بها كلمة See Out و التي بدورها تستخدم للحصول على قيمة المتغير.",,,,,,,,,,
الأساسيات,إدخال بيانات من المستخدم,الفرق بين الأمر cin و الأمر cout,,"الأمر cin نضع بعده إسم المتغير الذي سنخزن القيمة التي يدخلها المستخدم فيها و تكون الأسهم باتجاه اليمين كالتالي.

",,,"// x قم بتخزين ما سيدخله المستخدم في المتغير
cin >> x;",,,,,,,
الأساسيات,إدخال بيانات من المستخدم,الفرق بين الأمر cin و الأمر cout,,"الأمر cout نضع بعده أي شيء نريد عرضه أو أي متغير نريد عرض قيمته و تكون الأسهم باتجاه اليسار كالتالي.

	
",,,"// x قم بعرض القيمة المدخلة في المتغير
cout << ""x = "" < < a;",,,,,,,
الأساسيات,إدخال بيانات من المستخدم,المشاكل التي يسببها إدخال مسافات فارغة,,"في حال كان ما أدخلته يحتوي على مسافات فارغة, سيسبب ذلك مشاكل في الكود لأن المترجم سيعتبر أنك تحاول إدخال مجموعة قيم و ليس قيمة واحدة.
	عندما يجدك المترجم قمت بإدخال مجموعة قيم في ذات الوقت الذي تحاول فيه أن تخزن قيمة واحدة فقط في متغير, سيعتبر أنك تريد إدخال القيم الأخرى في المرات القادمة التي تطلب فيها من المستخدم أن يدخل قيم.
",تذكر دائماً أن الأمر cin >> يستخدم لإدخال رقم أو كلمة واحدة فقط بمعنى أنه لا يجب أن يحتوي ما تدخله على مسافات فارغة.,,,,"في المثال التالي, قمنا بإنشاء برنامج يطلب من المستخدم إدخال إسمه و بريده الإلكتروني, بعدها يعرض له ما قام بإدخاله.
	عند تشغيل البرنامج سنتعمد إدخال إسم المستخدم الكامل (إسمه و إسم عائلته) مع وضع مسافة فارغة بينهما حتى ترى الخطأ الذي سيحدث.","#include <iostream>

using namespace std;

int main()
{
    // لتخزين المعلومات التي سيدخلها المستخدم لاحقاً email و name قمنا بتجهيز المتغيرين
    string name;
    string email;

    // name هنا سيطلب من المستخدم إدخال إسمه و من ثم سيتم تخزين الإسم الذي يدخله في المتغير
    cout << ""Enter your name: "";
    cin >> name;

    // email هنا سيطلب من المستخدم إدخال بريده الإلكتروني و من ثم سيتم تخزين البريد الذي يدخله في المتغير
    cout << ""Enter your email: "";
    cin >> email;

    // في الأخير قمنا بعرض المعلومات التي يدخلها المستخدم بشكل مرتب
    cout << ""\n\n---------------------"";
    cout << ""\nName = "" << name;
    cout << ""\nEmail = "" << email;

    return 0;
}
		","Enter your name: Mhamad Harmush
Enter your email:                <- لاحظ أنه لم ينتظرنا لندخل البريد الإلكتروني بل إعتبر أنه تم إدخاله

---------------------
Name = Mhamad                    <- name فقط في المتغير  Mhamad لاحظ أنه قام بوضع
Email = Harmush                  <- بشكل تلقائي email في المتغير  Harmush لاحظ أنه قام بوضع
",,,
الأساسيات,إدخال بيانات من المستخدم,إدخال نص بواسطة الدالة getline(),,"إذا أردت جعل المستخدم قادر على إدخال أكثر من كلمة و تخزين كل ما يدخله في متغير نصّي واحد, يمكنك إستخدام الأمر cin لجعل المترجم ينتظر المستخدم حتى يدخل ما يشاء, و من ثم تقوم بتغليف ما سيتم إدخاله بواسطة الدالة getline() و التي ستقوم باعتبار كل ما تم إدخاله عبارة عن نص واحد.



","ملاحظة: الدالة getline() موجودة في الحزمة std و لهذا يجب ان تكتب std::getline(std::cin, x) إن لم تكن تريد تضمين الحزمة std في برنامجك.",,"// x قم بتخزين كل النص الذي سيدخله المستخدم في المتغير
getline(cin, x);",إذاً الأمر التالي هو ما تحتاجه لإستقبال نص من المستخدم.,,,,,,
الأساسيات,إدخال بيانات من المستخدم,إدخال نص بواسطة الدالة getline(),,"في المثال التالي قمنا بتعريف مثال يطلب من المستخدم إدخال إسمه الكامل (إسمه و إسم عائلته) و من ثم يعرض له رسالة ترحيب.
",,,,,,"#include <iostream>

using namespace std;

int main()
{
	// لتخزين الإسم الذي سيدخله المستخدم لاحقاً name قمنا بتجهيز المتغير
	string name;
	
	// name هنا سيطلب من المستخدم إدخال إسمه الكامل و من ثم سيتم تخزين الإسم الذي يدخله في المتغير
    cout << ""Enter your name: "";
	getline(cin, name);
	
	// في الأخير قمنا بعرض المعلومات التي يدخلها المستخدم بشكل مرتب
	cout << ""Welcome "" << name;
	
    return 0;
}
		","Enter your name:  Mhamad Harmush
Welcome Mhamad Harmush
",,,
التعامل مع الأعداد,التعامل مع الأعداد,مفهوم التعامل مع الأعداد,,"هناك الكثير من الدوال الجاهزة في C++ التي يمكن استخدامها لإجراء عمليات حسابية. بعض هذه الدوال يمكن استخدامها بشكل مباشر لأنها تعتبر معروفة بالنسبة لمترجم اللغة بشكل إفتراضي و بعض الدوال بحاجة لأن تضّمنها بنفسك أولاً حتى تتمكن من استخدامها.
بالإجمال, حتى تستطيع استخدام الدوال المخصصة لإجراء العمليات الحسابية, يجب تضمين الملف cmath الذي يحتويها.
	لذلك ستجد أننا سنضيف السطر التالي في أي مثال نستخدم فيه إحدى الدوال التي سنتعلمها في هذا الدرس.

	


",هذا السطر يعني أننا نريد إضافة محتوى الملف cmath في البرنامج مما يجعلنا قادرين على استخدام الدوال الموجودة فيه.,,#include <cmath>,,,,,,,
التعامل مع الأعداد,التعامل مع الأعداد,دوال الملف cmath,,"الجدول التالي يحتوي على دوال الملف cmath الأكثر استخداماً.
		  
		","ملاحظة
  يكفي فقط أن تعرف أن الدوال التي ذكرناها متوفرة لتستخدمها عند الحاجة لها مستقبلاً.
  و من الطبيعي أن لا تكون أغلب هذه الدوال قد مرت معك من قبل لأن هذه الدوال تستخدم في الغالب في العمليات الحسابية التي تدرس في الرياضيات و الفيزياء, لذلك على الأرجح قد لا تستخدم أغلب الدوال المذكورة في البرامج العادية.
 ",,"['abs(x)\n   ترجع القيمة المطلقة ( Absoulte Value ) للعدد الذي نمرره لها مكان البارامتير x.', 'fabs(x)\n   ترجع القيمة المطلقة للعدد الذي نوعه float و الذي نمرره لها مكان الباراميتر x.', 'floor(x)\n   ترجع العدد الصحيح الأصغر أو الذي يساوي العدد الذي نمرره لها مكان الباراميتر x.', 'ceil(x)\n   ترجع العدد الصحيح الأكبر أو الذي يساوي العدد الذي نمرره لها مكان الباراميتر x.', 'rint(x)\n   ترجع أقرب عدد صحيح للعدد الذي نمرره لها مكان الباراميتر x.', 'fmax(x, y)\n   ترجع العدد الأكبر بين العددين اللذين نمررهما لها مكان الباراميترين x و y.', 'fmin(x, y)\n   ترجع العدد الأصغر بين العددين اللذين نمررهما لها مكان الباراميترين x و y.', 'fmod(x, y)\n   ترجع الرقم الذي يتبقى من قسمة قيمة البارامتير x على قيمة البارامتير y.', 'pow(x, y)\n   تضاعف قيمة الباراميتر x بقيمة الباراميتر y ثم ترجع الناتج.', 'sqrt(x)\n   ترجع قيمة الجزر التربيعي (Square Root) للعدد الذي نمرره لها مكان الباراميتر x.', 'cbrt(x)\n   ترجع قيمة الجزر التكعيبي ( Cube Root ) للعدد الذي نمرره لها مكان الباراميتر x.', 'fdim(x, y)\n   إذا كانت قيمة x أكبر من قيمة y ترجع الفارق بينهما و الذي يساوي x-y, مع الإشارة إلى أنها ترجع الفارق كعدد إيجابي دائماً ( Positive Number ).\n   غير ذلك ترجع صفر مهما كانت قيمة الأعداد المدخلة.', 'fma(x, y, z)\n   ترجع قيمة x * y + z مع الحفاظ على أي رقم موجود بعد الفاصلة.', 'hypot(x, y)\n   ترجع قيمة وتر المثلث ( Hypotenuse ).\n   أي ترجع قيمة sqrt(x2 +y2) مع الحفاظ على أي رقم موجود بعد الفاصلة.', 'exp(x)\n   ترجع قيمة ex, أي قيمة المتسارع ( Exponential ) للعدد الذي نمرره لها مكان الباراميتر x.', 'expm1(x)\n   ترجع قيمة ex - 1, أي قيمة المتسارع ( Exponential ) للعدد الذي نمرره لها مكان الباراميتر x ناقص واحد.', 'log(x)\n   ترجع قيمة loge(x), أي قيمة اللوغاريتم ( Logarithm ) للعدد الذي نمرره لها مكان الباراميتر x.', 'log2(x)\n   ترجع قيمة log2(x), أي قيمة اللوغاريتم الثنائي ( Binary Logarithm ) للعدد الذي نمرره لها مكان الباراميتر x.', 'log10(x)\n   ترجع قيمة log10(x), أي قيمة اللوغاريتم العشري ( Decimal Logarithm ) للعدد الذي نمرره لها مكان الباراميتر x.', 'sin(x)\n   ترجع قيمة جيب الزاوية أو الجيب ( Sine ) للعدد الذي نمرره لها مكان الباراميتر x.', 'asin(x)\n   ترجع قيمة الجيب العكسي أو جيب الزاوية القوسي ( Arc Sine ) للعدد الذي نمرره لها مكان الباراميتر x.', 'asinh(x)\n   ترجع قيمة جيب الزاوية الزائدي أو الجيب الزائدي ( Hyperbolic Sine ) للعدد الذي نمرره لها مكان الباراميتر x.', 'cos(x)\n   ترجع قيمة جيب التمام ( Cosine ) للعدد الذي نمرره لها مكان الباراميتر x.', 'acos(x)\n   ترجع قيمة جيب التمام العكسي أو جيب تمام الزاوية القوسي ( Arc Cosine ) للعدد الذي نمرره لها مكان الباراميتر x.', 'cosh(x)\n   ترجع قيمة جيب التمام الزائدي ( Hyperbolic Cosine ) للعدد الذي نمرره لها مكان الباراميتر x.', 'tan(x)\n   ترجع قيمة الظل أو ظل الزاوية أو المماس ( Tangent ) للعدد الذي نمرره لها مكان الباراميتر x.', 'atan(x)\n   ترجع قيمة الظل العكسي أو ظل الزاوية القوسي ( Arc Tangent ) للعدد الذي نمرره لها مكان الباراميتر x.', 'tanh(x)\n   ترجع قيمة الظل الزائدي أو المماس الزائدي ( Hyperbolic Tangent ) للعدد الذي نمرره لها مكان الباراميتر x.']", إسم الدالة مع تعريفها,,,,,,
التعامل مع الأعداد,التعامل مع الأعداد,توليد أرقام عشوائية,,"في حالات كثيرة قد تحتاج إلى توليد قيم عشوائية في برامجك و قد تكون بحاجة إلى تحديد نطاق الأعداد العشوائية التي ترغب في توليدها, فمثلاً في لعبة الزهر قد ترغب في الحصول على قيمة عشوائية بين 1 و 6.
",,,,,,,,,,
التعامل مع الأعداد,التعامل مع الأعداد,الدالة rand(),,"للحصول على رقم عشوائي, يمكنك استخدام دالة إسمها rand() موجودة في الملف stdlib.h كالتالي.
إذاً استخدام الدالة rand() لوحده لا يضمن أن تحصل على رقم عشوائي مختلف في كل مرة تقوم فيها بتشغيل البرنامج.
	لهذا السبب بالتحديد, عليك أن تعلم مترجم لغة C++ بأن يعيد تغيير الإحتمالات العشوائية عند تشغيل البرنامج و قبل استداعاء الدالة rand() و هذا ما سنتعلمه الآن.
",,,,,,"#include <iostream>
#include <stdlib.h>

using namespace std;

int main()
{
	// هنا قمنا بطباعة رقم عشوائي
    cout << ""Random number: "" << rand();
    
	return 0;
}
		","Random number: 41
إذا قمنا بتشغيل البرنامج مرة ثانية سنحصل على نفس النتيجة السابقة كالتالي.
Random number: 41
إذا قمنا بتشغيل البرنامج مرة ثالثة سنحصل على نفس النتيجة السابقة كالتالي.
Random number: 41
",,,
التعامل مع الأعداد,التعامل مع الأعداد,الدالتين srand() و time(),,"الدالة srand() تستخدم لتغيير سلسلة القيم العشوائية التي سيتم توليدها عند استدعاء الدالة rand() مما يجعلك تحصل على قيم عشوائية مختلفة عن القيم التي حصلت عليها في المرة السابقة التي قمت فيها بتشغيل البرنامج.
إفتراضياً, الدالة rand() تستخدم المدى srand(1) في كل مرة يتم فيها تشغيل البرنامج, لهذا كنا نحصل على نفس القيم العشوائية عند البرنامج.


",ملاحظة: لاستخدام الدالة srand() يجب تضمين الملف stdlib.h و لاستخدام الدالة time() يجب تضمين الملف time.h.,,,,"لتمرير رقم مختلف للدالة srand() و بشكل تلقائي, يمكنك تمرير عدد الثواني الموجودة من 1-1-1970 و حتى وقت الجهاز الحالي و هذا تحصل عليه من خلال استدعاء الدالة time(0) و تمريرها للدالة srand() كما سنرى في المثال التالي.","#include <iostream>
#include <stdlib.h>
#include <time.h>

using namespace std;

int main()
{
	// هنا قمنا بتغيير سلسلة القيم العشوائية التي سيتم توليدها
	srand(time(0));
	
	// هنا قمنا بطباعة رقم عشوائي
    cout << ""Random number: "" << rand();
    
	return 0;
}
		","Random number: 1537
إذا قمنا بتشغيل البرنامج مرة ثانية سنحصل على نتيجة عشوائية مختلفة عن النتيجة السابقة كالتالي.
Random number: 1579
إذا قمنا بتشغيل البرنامج مرة ثالثة سنحصل على نتيجة عشوائية مختلفة عن النتيجة السابقة كالتالي.
Random number: 1621
",,,
التعامل مع الأعداد,التعامل مع الأعداد,الدالتين srand() و time(),,"المثال التالي يوضج طريقة تحديد أعلى و أدنى قيمة عشوائية يمكن أن يتم إرجاعها.
",,,,,,"#include <iostream>
#include <stdlib.h>
#include <time.h>

using namespace std;

int main()
{
    // هنا قمنا بتغيير سلسلة القيم العشوائية التي سيتم توليدها
    srand(time(0));

	// هنا قمنا بإنشاء رقم عشوائي بين 1 و 10
    int x = rand() % 10 + 1;

    // هنا قمنا بطباعة رقم عشوائي
    cout << ""Random number: "" << x;

    return 0;
}

		","سنحصل على رقم عشوائي بين 1 و 10 كالتالي عند التشغيل.
Random number: 3
",,,
التعامل مع النصوص,التعامل مع النصوص,مفهوم النصوص,,"في عالم البرمجة, نقول للنص ""String"" سواء كان يتألف من حرف واحد, كلمة, جملة أو نص كبير جداً.
	و من هذا المنطلق نستنتج أن النص عبارة عن سلسلة من الأحرف ليس لها حجم محدد.
",,,,,"في لغة C++ تم إنشاء النوع string خصيصاً لتخزين القيم النصية و هو موجود في الحزمة std.
	لذلك إن لم تقم بتضمين الحزمة std في برنامجك, يجب أن تعرّف النص بهذا الشكل std::string.
	بالإضافة إلى ذلك, القيمة النصية يجب وضعها بين علامة التنصيص """" كما في المثال التالي.
","#include <iostream>

using namespace std;

int main()
{
	// ""Hello World!"" و قيمته النص s هنا قمنا بتعريف متغير نصي إسمه
    string s = ""Hello world!"";

    // s هنا قمنا بطباعة قيمة المتغير
    cout << s;

    return 0;
}
		","Hello world!
",,,
التعامل مع النصوص,التعامل مع النصوص,مفهوم دمج النصوص,,"دمج النصوص ( Concatenation ) يقصد به وضع سلسلة من النصوص بجانب بعضها لعرضها كنص واحد. و هذا الأمر ستحتاجه في أي تطبيق.
فمثلاً, في البرامج أو المواقع التي تستخدمها تلاحظ أنه عند إنشاء حساب جديد يطلب منك أن تدخل إسمك على مرحلتين كالتالي:
	- الإسم ( First Name ).
	- إسم العائلة ( Last Name ).
بعد أن تنشئ حسابك تلاحظ أنه قام بعرض إسمك الكامل ( الإسم + إسم العائلة ).
	عند وضع الإسمين بجانب بعضهما و كأنهما نص واحد يكون المبرمج فعلياً قد قام بدمجهما فقط و ليس إعادة كتابتهما من جديد.
",,,,,"في المثال التالي سنقوم بتعريف المتغير firstName لنضع فيه الإسم, و المتغير lastName لنضع فيه إسم العائلة, و المتغير fullName لنضع فيه الإسم و إسم العائلة.
","#include <iostream>

using namespace std;

int main()
{
	// و وضعنا فيه نص يمثل الإسم firstName هنا قمنا بإنشاء المتغير
    string firstName = ""Mhamad"";

	// و وضعنا فيه نص يمثل إسم العائلة lastName هنا قمنا بإنشاء المتغير
    string lastName = ""Harmush"";

	// و أضفنا بينهما مسافة فارغة lastName و إسم العائلة الموجود في المتغير firstName و وضعنا فيه الإسم الموجود في المتغير fullName هنا قمنا بإنشاء المتغير
    string fullName = firstName + "" "" + lastName;
	
    // و يالتالي سيتم عرض الإسم الكامل الذي قمنا بدمجه و وضعه فيه fullName هنا عرضنا قيمة المتغير
    cout << fullName;

    return 0;
}
		","Mhamad Harmush
",,,
التعامل مع النصوص,التعامل مع النصوص,كيف يتم تخزين النص,,"لنفترض أننا قمنا بتعريف string إسمه s و أعطيناه قيمة.
",,,"
	    مثال
		string s = ""welcome to harmash.com"";
		
	",,,,,,,
التعامل مع النصوص,التعامل مع النصوص,كيف يتم تخزين النص,,"بما أننا نستخدم أحرف إنجليزية, سيتم تخزين نص المتغير s في الذاكرة حرفاً حرفاً و بالترتيب كما في هذه الصورة التالية.","مصطلحات تقنية
عدد أحرف النص يسمى Length.
رقم الخانة يسمى index.
أرقام الخانات يقال لها indices أو indexes.
إذا قمنا بأخذ جزء من النص فهذا الجزء يسمى substring.",https://harmash.com/tutorials/cplusplus/strings/e8249407-1a48-40dd-b171-851a7e2e8835_string.PNG,,,,,,,,
التعامل مع النصوص,التعامل مع النصوص,الوصول لأحرف النص,,"في حال أردت المرور على أحرف أي نص, سيتم إعتبار أن الخانات قد تم ترقيمها من اليسار إلى اليمين و إبتداءاً من الرقم 0 كما رأينا قبل قليل.

الآن إذا أردنا تحديد رقم الخانة التي نريد الوصول إليها سواء لعرض الحرف الموجود فيها أو لتبديله, فيجب أن نضع إسم المتغير الذي يحتوي على النص, ثم الرمز [] و فيه نحدد رقم الخانة التي نريد الوصول إليها.
",,,,,"في المثال التالي, قمنا بعرض أول خمسة أحرف موجودة في النص.
","#include <iostream>

using namespace std;

int main()
{
	// s هنا قمنا بتعريف متغير نصي إسمه
    string s = ""Where is my book?"";

    // s هنا قمنا بطباعة أول 5 أحرف موجودة في المتغير
    cout << s[0] << s[1] << s[2] << s[3] << s[4];

    return 0;
}
		","Where
",,,
التعامل مع النصوص,التعامل مع النصوص,فكرة الثابت string::npos ,,"هذا المتغير الثابت موجود في الكلاس string و فكرته هي أنك حين تحاول البحث في النص عن قيمة ما و لا تجدها فإنه يتم إرجاع قيمته لك للإشارة إلى أنه قد تم البحث في كل النص و لم يتم إيجاد القيمة التي تبحث عنها.
إنتبه لنقطة مهمة و هي أنك لست مضطر لحفظ قيمته, بل يكفي فقط أن تعرف كيف يتم إستخدامه في الكود.
لمعرفة ما إن تم إيجاد الكلمة المراد البحث عنها في النص أم لا, قمنا بمقارنة القيمة التي أرجعتها الدالة find() بعد أن إنتهت من البحث مع قيمة المتغير string::npos.
	إذا كانت القيمة التي أرجعتها الدالة find() تساوي قيمة المتغير string::npos فهذا يعني أنه لم يتم إيجاد الكلمة المراد البحث عنها. إذا لم تكن تساويها فهذا يعني أنه تم إيجادها.
",,,,,,"#include <iostream>

using namespace std;

int main()
{
	// s هنا قمنا بتعريف متغير نصي إسمه
    string s = ""I'm learning c++ from harmash.com"";

	// result و تخزين نتيجة البحث في المتغير ""java"" عن الكلمة s هنا قمنا بالبحث في النص الموجود في المتغير
	size_t result = s.find(""java"");
	
	// string::npos مع قيمة result هنا قمنا بمقارنة قيمة
    // إذا كانت متساويتين فهذا يعني أنه لم يتم إيجاد الكلمة التي بحثنا عنها 
	if (result == string::npos)
	{
		cout << ""Word not found!"";
	}
	// إن لم يكونا متساويتين, فهذا يعني أنه تم إيجاده الكلمة التي بحثنا عنها و سيتم طباعة رقم أول خانة تم عنده إيجاد الكلمة
	else
	{
		cout << ""Word is found at index "" << result;
	}

    return 0;
}
		","Word not found!
",,,
التعامل مع النصوص,التعامل مع النصوص,دوال الكلاس string,,"الجدول التالي يحتوي على دوال الكلاس string الأكثر استخداماً.

	    
			إسم الدالة مع تعريفها
		
		",,,"['int length()\n   ترجع رقم يمثل عدد أحرف النص الذي قام باستدعائها.\n   للدقة, فإن الرقم الذي ترجعه يمثل من كم Byte يتألف النص.', 'int size()\n   ترجع رقم يمثل عدد أحرف النص الذي قام باستدعائها تماماً مثل الدالة length().', 'string substr(int pos=0, int len = npos)\n   ترجع نص عبارة عن جزء من النص (Substring) الذي قام باستدعائها.\n   مكان الباراميتر pos نمرر index الحرف الذي نريد البدء بنسخ النص من عنده.\n   مكان الباراميتر len يمكنك تمرير رقم يمثل كم حرف تريد أن تنسخ من عند index الباراميتر pos إن لم ترد نسخ كل النص الموجود.', 'int find(string str)\n   تبحث في النص الذي قام بإستدعائها عن أول index يوجد إبتداءاَ من عنده نفس النص الذي نمرره لها مكان الباراميتر str و ترجعه.', 'int rfind(string str)\n   تبحث في النص الذي قام بإستدعائها عن آخر index يوجد إبتداءاَ من عنده نفس النص الذي نمرره لها مكان الباراميتر str و ترجعه.', 'string replace(int pos, int len, string replacement)\n   تستخدم لتعديل جزء محدد من النص الذي قام باستدعائها.\n   مكان الباراميتر pos نمرر index الحرف الذي نريد البدء بتغيير النص من عنده.\n   مكان الباراميتر len نمرر رقم يمثل كم حرف تريد أن تبدل إعتباراً من عند index الباراميتر pos.\n   مكان الباراميتر replacement نمرر النص الذي سيتم إضافته مكان الجزئية التي سيتم حذفها.', 'void swap(string str)\n   تبدل محتوى النص الذي قام بإستدعائها بمحتوى النص الذي نمرره مكان الباراميتر str.\n   كما أنها تبدل محتوى المتغير الذي نمرره مكان الباراميتر str بمحتوى النص الذي قام باستدعائها.', 'string append (const string str)\n   تضيف قيمة النص الذي نمرره مكان الباراميتر str في آخر النص الذي قام باستدعائها و ترجع النص الناتج عند دمجهمها معاً.', 'bool empty()\n   ترجع true إذا كان النص الذي قام باستدعائها فارغ (أي لا يوجد فيه أي حرف).\n   و ترجع false إن لم يكن كذلك.', 'void clear()\n   تمسح كل الأحرف الموجودة في النص الذي قام باستدعائها.', 'int compare (const string str)\n   تقارن حجم النص الذي قام باستدعائها مع حجم النص الذي نمرره لها مكان الباراميتر str.\n   ترجع 0 في حال كان حجمهم متساوي.\n   ترجع 1 في حال كان عدد أحرف النص الذي قام باستدعائها أكبر.\n   ترجع -1 في حال كان عدد أحرف النص الذي قام باستدعائها أصغر.', 'string insert (int pos, const string str)\n   تضيف قيمة النص الذي نمرره مكان الباراميتر str في النص الذي قام باستدعائها عند Index الخانة التي نحددها مكان الباراميتر pos و ترجع النص الناتج عند دمجهمها معاً.\n']
  
 
",,,,,,,
الحلقات,مفهوم الحلقات,مفهوم الحلقات,,"نستخدم الحلقات ( Loops ) بهدف تكرار نفس الكود عدة مرات.
	إذاً أي كود نريده أن يتنفذ عدة مرات, نقوم بكتابته داخل حلقة فتقوم هي بإعادة تنفيذ الكود قدر ما شئنا ضمن شروط معينة نقوم نحن بتحديدها.

طريقة تنفيذ الأوامر و الحلقات في الذاكرة
الأوامر في العادة تتنفذ بتسلسل وراء بعضها, و لكن الحلقات تجعل سهم تنفيذ الأوامر يقف عندها فيقوم بتنفيذ الأوامر التي بداخلها عدة مرات, و بعد أن يخرج من الحلقة يعود و يكمل تنفيذ باقي الأوامر الموجودة بعدها.


عندما تتنفذ الحلقة فإن الأوامر الموضوعة فيها تنفذ بشكل منفصل عن باقي الأوامر الموجودة في البرنامج, أي يمكنك إعتبار أن جميع أوامر الحلقة توضع في مكان خاص في الذاكرة, هذا المكان يسمى scope.
بعد أن تتنفذ جميع أوامر الحلقة في هذا الـ scope, يتم مسح الـ scope كلياً من الذاكرة و هذه العملية تسمى Destroy.
",,,,,,,,,,
الحلقات,الحلقة for,تعريف الحلقة for,,"نستخدم الحلقة for إذا كنا نريد تنفيذ الكود عدة مرات محددة, فمثلاً إذا كنا نريد تنفيذ كود معين 10 مرات, نضعه بداخل حلقة تعيد نفسها 10 دورات.
	


",,,"           for( initialisation; condition; increment أو decrement )
   {
       // statements
   }",طريقة إستخدامها,,,,,,
الحلقات,الحلقة for,تعريف الحلقة for,,"initialisation:   هي أول خطوة تتنفذ في الحلقة و هي تتنفذ مرة واحدة فقط على عكس جميع العناصر الموجودة في الحلقة.
		في هذه الخطوة نقوم بتعريف متغير ( يسمى عداد ) و نضع بعده ;.
		
		condition:   هي ثاني خطوة تتنفذ في الحلقة و هي تتنفذ في كل دورة.
		في هذه الخطوة نقوم بوضع شرط يحدد متى تتوقف الحلقة, في كل دورة يتم التأكد أولاً إذا تحقق هذا الشرط أم لا, و نضع بعده ;.
		هنا طالما أن نتيجة الشرط تساوي true سيعيد تكرار الكود.
		
statements:   هي الخطوة الثالثة, و تعني تنفيذ جميع الأوامر الموجودة في الحلقة و هي تتنفذ في كل دورة.
		بعد أن تتنفذ جميع الأوامر سيصعد إلى الخطوة الأخيرة التي تحدث في نهاية كل دورة و هي إما زيادة قيمة العداد أو إنقاصها.
		
 decrement أو increment:   هي الخطوة الرابعة و الأخيرة, و هي تتنفذ في كل دورة.
        هنا نحدد كيف تزداد أو تنقص قيمة العداد, و لا نضع بعده ;.
	


","تذكر فقط أن جميع هذه الخطوات تتكرر في كل دورة ما عدا أول خطوة, و السبب أننا لا نحتاج إلى تعريف عداد جديد في كل دورة, بل نستعمل العداد القديم و الذي من خلاله نعرف في أي دورة أصبحنا.",,,,,,,,,
الحلقات,الحلقة for,مثال حول الحلقة for,,"في المثال التالي قمنا بتعريف حلقة تطبع جميع الأرقام من 1 إلى 10.
",,,,,,"#include <iostream>

using namespace std;

int main()
{
    // تتألف من 10 دورات. في كل دورة تطبع قيمة العداد المستخدم فيها for هنا قمنا بإنشاء حلقة
    for( int i=1; i<=10; i++ )
    {
        cout << i << endl;
    }
	
    return 0;
}
		","1
2
3
4
5
6
7
8
9
10
",,,
الحلقات,الحلقة while,تعريف الحلقة while,,"نستخدم الحلقة while إذا كنا نريد تنفيذ الكود عدة مرات, ولكننا لا نعرف كم مرة بالتحديد لأننا نريد إيقاف التنفيذ إذا تحقق شرط معين.
	هذه الحلقة تتوقف عن تكرار نفسها إذا لم يتحقق الشرط الذي وضعناه لها.
هنا كأننا نقول: ""طالما أن الشرط يزال يتحقق إستمر في تكرار الكود"".",,,"
      initialisation;
            while( condition )
   {
       // statements
       increment أو decrement;
   }
    ",طريقة إستخدامها,,,,,,
الحلقات,الحلقة while,تعريف الحلقة while,,"initialisation:   هي أول خطوة تتنفذ في الحلقة و هي تتنفذ مرة واحدة فقط على عكس جميع العناصر الموجودة في الحلقة.
		في هذه الخطوة نقوم بتعريف متغير ( يسمى عداد ).
		
		condition:   هي ثاني خطوة تتنفذ في الحلقة و هي تتنفذ في كل دورة.
		في هذه الخطوة نقوم بوضع شرط يحدد متى تتوقف الحلقة, في كل دورة يتم التأكد أولاً إذا تحقق هذا الشرط أم لا.
		هنا طالما أن نتيجة الشرط تساوي true سيعيد تكرار الكود.
		
statements:   هي الخطوة الثالثة, و تعني تنفيذ جميع الأوامر الموجودة في الحلقة و هي تتنفذ في كل دورة.
		
decrement أو increment:   هي الخطوة الرابعة و الأخيرة, و هي تتنفذ في كل دورة.
        هنا نحدد كيف تزداد أو تنقص قيمة العداد.

","تذكر فقط أن جميع هذه الخطوات تتكرر في كل دورة ما عدا أول خطوة, و السبب أننا لا نحتاج إلى تعريف عداد جديد في كل دورة, بل نستعمل العداد القديم و الذي من خلاله نعرف في أي دورة أصبحنا.",,,,,,,,,
الحلقات,الحلقة while,مثال حول الحلقة while,,في المثال التالي قمنا بتعريف حلقة تطبع جميع الأرقام من 1 إلى 10.,,,,"
","
","#include <iostream>

using namespace std;

int main()
{
    // هنا قمنا بتعريف المتغير الذي استخدمناه كعداد في الحلقة
    int i=1;
 
    // تظل تنفذ الأوامر الموضوعة فيها طالما أن قيمة العدد لا تزال أصغر أو تساوي 10 while هنا أنشأنا حلقة
    while( i<=10 )
    {
        // في كل دورة سيتم طباعة قيمة العداد ثم إضافة 1 عليها
        cout << i << endl;
        i++;
    }
 
    return 0;
}
		","1
2
3
4
5
6
7
8
9
10
",,,
الحلقات,الحلقة do while,تعريف الحلقة do while,,"نستخدم الحلقة do while إذا كنا نريد تنفيذ الكود عدة مرات, ولكننا لا نعرف كم مرة بالتحديد لأننا نريد إيقاف التنفيذ إذا تحقق شرط معين.
	هذه الحلقة تتوقف عن تكرار نفسها إذا تحقق الشرط الذي وضعناه لها.
الفرق الوحيد بينها و بين الحلقة while أنها تتنفذ مرة واحدة على الأقل لأنها تتأكد من الشرط بعد تنفيذ الأوامر و ليس قبلهم.
هنا كأننا نقول: ""نفذ الكود الموضوع و طالما أن الشرط لا يزال يتحقق أعد تنفيذه"".",,,"initialisation;
do{
       // statements
       increment أو decrement;
   }
   While( condition );
     
 ",طريقة إستخدامها,,,,,,
الحلقات,الحلقة do while,تعريف الحلقة do while,,"initialisation:   هي أول خطوة تتنفذ في الحلقة و هي تتنفذ مرة واحدة فقط على عكس جميع العناصر الموجودة في الحلقة.
		في هذه الخطوة نقوم بتعريف متغير ( يسمى عداد ).
		
statements:   هي الخطوة الثانية, و تعني تنفيذ جميع الأوامر الموجودة في الحلقة و هي تتنفذ في كل دورة.
		
decrement أو increment:   هي الخطوة الثالثة, و هي تتنفذ في كل دورة.
        هنا نحدد كيف تزداد أو تنقص قيمة العداد.
		
		condition:   هي الخطوة الرابعة و الأخيرة و هي تتنفذ في كل دورة.
		في هذه الخطوة نقوم بوضع شرط يحدد متى تتوقف الحلقة, في نهاية كل دورة يتم التأكد إذا تحقق الشرط أم لا.
		هنا طالما أن نتيجة الشرط تساوي true سيعيد تكرار الكود.

","
تذكر فقط أن جميع هذه الخطوات تتكرر في كل دورة ما عدا أول خطوة, و السبب أننا لا نحتاج إلى تعريف عداد جديد في كل دورة, بل نستعمل العداد القديم و الذي من خلاله نعرف في أي دورة أصبحنا.",,,,,,,,,
الحلقات,الحلقة do while,مثال حول الحلقة do while,,"في المثال التالي قمنا بتعريف حلقة تطبع جميع الأرقام من 1 إلى 10.
",,,,,,"#include <iostream>

using namespace std;

int main()
{
    // هنا قمنا بتعريف المتغير الذي استخدمناه كعداد في الحلقة
    int i=1;
	
    // تظل تنفذ الأوامر الموضوعة فيها طالما أن قيمة العدد لا تزال أصغر أو تساوي 10 while هنا أنشأنا حلقة
    do
    {
        // في كل دورة سيتم طباعة قيمة العداد ثم إضافة 1 عليها
        cout << i << endl;
        i++;
    }
    while( i<=10 );
	
    return 0;
}
		","1
2
3
4
5
6
7
8
9
10
",,,
الحلقات,جملة التحكم break,تعريف الجملة break,,"الجملة break تستخدم في الحلقات و في الجملة switch.
	بمجرد ان تنفذ الجملة break فإنها توقف الـ scope بأكمله و تخرج منه و تمسحه من الذاكرة ثم تنتقل للكود الذي يليه في البرنامج.",,,break;,"طريقة تعريفها
تتألف هذه الجملة من أمر واحد و يكتب على سطر منفرد.",,,,,,
الحلقات,جملة التحكم break,مثال حول جملة التحكم break,,"في المثال التالي قمنا بتعريف حلقة كانت ستطبع جميع الأرقام من 1 إلى 10 لولا أننا إستخدمنا الجملة break لجعل الحلقة تتوقف عندما تصبح قيمة العداد i تساوي 6.
",,,,,,"#include <iostream>

using namespace std;

int main()
{
    // تتألف من 10 دورات. في كل دورة تطبع قيمة العداد المستخدم فيها for هنا قمنا بإنشاء حلقة
    for( int i=1; i<=10; i++ )
    {
        // في كل دورة سيتم فحص قيمة العداد و بمجرد أن تصبح تساوي 6 سيتم إيقاف الحلقة نهائياً
        if( i == 6 ) {
            break;
        }
 
        cout << i << endl;
    }
	
    return 0;
}
		","1
2
3
4
5
إذاً الجملة break جعلت الحلقة تتوقف عندما أصبحت قيمة العداد i تساوي 6.
",,,
الحلقات,جملة التحكم continue,تعريف الجملة continue,,"نستخدم الجملة continue لتجاوز تنفيذ كود معين في الحلقة, إذاً نستخدمها لتجاوز جزء من كود الـ scope.
و نستخدمها تحديداً لإيقاف الدورة الحالية و الإنتقال إلى الدورة التالية في الحلقة, لا تقلق ستفهم المقصود من المثال.
	
",,,continue;,"طريقة تعريفها
تتألف هذه الجملة من أمر واحد و يكتب على سطر منفرد.",,,,,,
الحلقات,جملة التحكم continue,أمثلة حول جملة التحكم continue,المثال الأول,"في المثال التالي قمنا بتعريف حلقة تطبع جميع الأرقام من 1 إلى 10 ما عدا الرقم 3.
    إستخدمنا الجملة continue لجعل الحلقة تتجاوز الدورة الثالثة في الحلقة. أي لن يتم تنفيذ أمر الطباعة عندما تصبح قيمة العداد i تساوي 3.
",,,,,,"#include <iostream>

using namespace std;

int main()
{
    // تتألف من 10 دورات. في كل دورة تطبع قيمة العداد المستخدم فيها for هنا قمنا بإنشاء حلقة
    for (int i=1; i<=10; i++)
    {
        // في كل دورة سيتم فحص قيمة العداد, عندما تصبح تساوي 3 سيتم الإنتقال إلى الدورة التالية في الحلقة بدون تنفيذ أمر الطباعة الموضوع بعدها
        if (i == 3) {
            continue;
        }
	
        cout << i << endl;
    }
	
    return 0;
}","1
2
4
5
6
7
8
9
10
إذاً الجملة continue جعلت الحلقة تتجاوز الدورة الثالثة, لذلك لم تطبع الرقم 3 لأنها لم تنفذ أمر الطباعة في الدورة الثالثة.
",,,
الحلقات,جملة التحكم continue,أمثلة حول جملة التحكم continue,المثال الثاني,"في المثال التالي قمنا بتعريف حلقة تطبع جميع الأرقام المفردة من 1 إلى 10.
    إستخدمنا الجملة continue لجعل الحلقة تتجاوز كل دورة تكون فيها قيمة العداد i عبارة عن عدد مفرد.
",,,,,,"#include <iostream>

using namespace std;

int main()
{
    // تتألف من 10 دورات. في كل دورة تطبع قيمة العداد المستخدم فيها for هنا قمنا بإنشاء حلقة
    for (int i=1; i<=10; i++)
    {
        // في كل دورة سيتم فحص قيمة العداد, في حال كانت مزدوجة سيتم الإنتقال إلى الدورة التالية في الحلقة بدون تنفيذ أمر الطباعة الموضوع بعدها
        if (i%2 == 0) {
            continue;
        }
 
        cout << i << endl;
    }
	
    return 0;
}","1
3
5
7
9
إذاً الجملة continue جعلت الحلقة تتجاوز كل دورة كانت فيها قيمة العداد عبارة عن عدد مزدوج.
",,,
الدوال,مفهوم الدوال,مفهوم الدوال,,"الدالة ( Function ) عبارة عن مجموعة أوامر مجمعة في مكان واحد و تتنفذ عندما نقوم باستدعائها.
في هذا القسم سنتعلم كيفية إنشاء دوال جديدة و كيفية استخدامها.

	


","
أسماء بعض الدوال التي قمنا باستخدامها في الدروس السابقة.
length();
insert();
replace();
fmax();
floor();",,,,,,,,,
الدوال,مفهوم الدوال,مفهوم الدوال,مصطلحات تقنية,"الدوال الجاهزة في C++ يقال لها Built-in Functions.
الدوال التي يقوم المبرمج بتعريفها يقال لها User-defined Functions.",,,,,,,,,,
الدوال,بناء الدوال,بناء الدوال,,عند تعريف أي دالة في C++ عليك إتباع الشكل التالي:,,,"returnType functionName(Parameter)
   {
          // Function Body
   }
     ",,,,,,,
الدوال,بناء الدوال,بناء الدوال,,"returnType: يحدد النوع الذي سترجعه الدالة عندما تنتهي أو إذا كانت لن ترجع أي قيمة.
functionName: يمثل الإسم الذي نعطيه للدالة, و الذي من خلاله يمكننا استدعاءها.
Parameter: المقصود بها الباراميترات ( وضع الباراميترات إختياري ).
Function Body: تعني جسم الدالة, و المقصود بها الأوامر التي نضعها في الدالة.

","نوع الإرجاع ( returnType ) في الدالة يمكن أن يكون أي نوع من أنواع البيانات الموجودة في C++ ( int - double - bool - string إلخ.. ).
 و يمكن وضع إسم لكلاس معين, و هنا يكون القصد أن الدالة ترجع كائن من هذا الكلاس ( لا تقلق ستتعلم هذا في لاحقاً ).
في حال كانت الدالة لا ترجع أي قيمة, يجب وضع الكلمة void مكان الكلمة returnType.",,,,,,,,,
الدوال,بناء الدوال,أمثلة حول تعريف دوال جديدة,المثال الأول,"في المثال التالي قمنا بتعريف دالة إسمها myFunction, نوعها void, و تحتوي على أمر طباعة فقط.
	بعدها قمنا باستدعائها في الدالة main() حتى يتم تنفيذ أمر الطباعة الموضوع فيها.
",,,,,,"#include <iostream>

using namespace std;

// عند استدعاءها تقوم بطباعة جملة myFunction هنا قمنا بتعريف دالة إسمها
void myFunction() {
    cout << ""My first function is called"";
}

int main()
{
	// حتى يتنفذ الأمر الموضوع فيها myFunction() هنا قمنا باستدعاء الدالة
    myFunction();

    return 0;
}
		","My first function is called
",,,
الدوال,بناء الدوال,أمثلة حول تعريف دوال جديدة,المثال الثاني,"هنا قمنا بتعريف دالة إسمها greeting, عند إستدعاءها نمرر لها إسم فتطبع رسالة ترحيب للإسم الذي تم تمريره لها.",,,,,,"#include <iostream>

using namespace std;

// عند استدعاءها تقوم بطباعة جملة greeting هنا قمنا بتعريف دالة إسمها
void greeting(string name)
{
    cout << ""Hello "" << name << "", welcome to our company."";
}

int main()
{
	// حتى يتنفذ الأمر الموضوع فيها greeting() هنا قمنا باستدعاء الدالة
    greeting(""Mhamad"");

    return 0;
}
		","Hello Mhamad, welcome to our company.
",,,
الدوال,بناء الدوال,أمثلة حول تعريف دوال جديدة,المثال الثالث,"هنا قمنا بتعريف دالة إسمها getSum, عند إستدعاءها نمرر لها عددين فترجع لنا ناتج جمعهما.",,,,,,"#include <iostream>

using namespace std;

// عند إستدعاءها نمرر لها عددين فتقوم بإرجاع ناتج جمعهما get_sum هنا قمنا بتعريف دالة إسمها
int getSum(int a, int b)
{
    return a + b;
}

int main()
{
	// x في المتغير get_sum() هنا قمنا بتخزين ناتج العددين 3 و 5 الذي سترجعه الدالة
    int result = getSum(3, 7);
	
	// و التي ستساوي 10 result هنا قمنا بعرض قيمة المتغير
	cout << ""Result = "" << result;
	
    return 0;
}
		","Result = 10
",,,
الدوال,إعطاء قيمة إفتراضية للباراميترات,إعطاء قيمة إفتراضية للباراميترات,,"تتيح لك C++ وضع قيم إفتراضية للباراميترات مما يجعلك عند إستدعاء الدالة مخيّر على تمرير قيم مكان الباراميترات بدل أن تكون مجبراً على ذلك.
القيمة الإفتراضية التي نضعها للباراميتر يقال لها Default Argument.

","إنتبه
إذا كانت الدالة تملك أكثر من باراميتر و تريد وضع قيمة إفتراضية لأحد الباراميترات التي تمكلها فقط فيجب وضع الباراميترات التي تملك قيم إفتراضية في الآخر.
إن لم ترد ذلك ستكون مجبر على وضع قيم إفتراضية لجميع الباراميترات الموجودة بعد أول باراميتر وضعت له قيمة إفتراضية.",,,,"في المثال التالي قمنا بتعريف دالة إسمها printLanguage.
هذه الدالة فيها باراميتر واحد إسمه language يملك النص ""English"" كقيمة إفتراضية.
كل ما تفعله هذه الدالة عند إستدعاءها هو طباعة قيمة الباراميتر language.","#include <iostream>

using namespace std;

// و يمكنك عدم تمرير قيمة لأنه أصلاً يملك قيمة language عند إستدعاءها يمكنك تمرير قيمة لها مكان الباراميتر .printLanguage هنا قمنا بتعريف دالة إسمها 
void printLanguage(string language=""English"")
{
    cout << ""Your language is "" << language << endl;
}

int main()
{
	// ""English"" و بالتالي ستظل قيمته language بدون تمرير قيمة مكان الباراميتر printLanguage() هنا قمنا باستدعاء الدالة
    printLanguage();
	
	// ""Arabic"" و بالتالي ستصبح قيمته language للباراميتر 'Arabic' مع تمرير القيمة printLanguage() هنا قمنا باستدعاء الدالة
	printLanguage(""Arabic"");
	
    return 0;
}
		","Your language is English
Your language is Arabic",,,
الدوال,أين يجب تعريف الدوال,أين يجب تعريف الدوال,,"مترجم لغة C++ يقرأ الكود سطراً سطراً مع تنفيذ الأوامر الموضوعة في كل سطر بشكل مباشر عندما يتم تشغيل البرنامج.
	لهذا السبب يجب دائماً أن تكون الدالة التي تريد استدعاءها معرّفة سابقاً حتى لا يظهر لك مشكلة عند تشغيل البرنامج.
","حل مشكلة عدم التعرف على الدالة
لحل مشكلة عدم التعرف على الدالة التي حدثت في المثال السابق عندنا خيارين:

إبقاء الدالة myFunction() مكانها و ذكر تعريفها ( Function Declartion ) في أول الملف فقط, و هذه الطريقة تعتبر الأكثر تفضيلاّ.
وضع الدالة myFunction() فوق الدالة main() حتى يقوم المترجم بقرائها و التعرف عليها و تصبح قادر على استدعاءها في الدالة main() الموجودة بعدها.",,,,"في المثال التالي, قمنا بوضع الدالة myFunction() بعد الدالة التي قمنا باستدعائها منها.
	المشكلة التي ستحدث عند التشغيل هنا سببها أن المترجم سيكون لا يعرف ما هي myFunction() حيث أنه تم استدعاءها قبل أن يقوم المترجم قد سبق و قرأها.
","#include <iostream>

using namespace std;

int main()
{
	// myFunction() هنا قمنا باستدعاء الدالة
    myFunction();

    return 0;
}

// التي تحتوي على أمر طباعة فقط myFunction هنا قمنا بتعريف الدالة
void myFunction()
{
    cout << ""My first function is called"";
}
		","سيظهر الخطأ التالي عند التشغيل و الذي يعني أن المترجم لم يعرف ما هي myFunction التي تحاول استدعاءها في السطر الثامن.
main.cpp|8|error: 'myFunction' was not declared in this scope|
",,,
الدوال,أين يجب تعريف الدوال,أين يجب تعريف الدوال,المثال الثاني,"في المثال التالي, قمنا بإبقاء الدالة myFunction() مكانها و ذكر تعريفها ( Function Declartion ) قبل أن يتم استدعاءها في الدالة main().
	إذاً لن يحدث أي مشكلة عند استدعاء الدالة myFunction() من الدالة main() لأن المترجم سيكون لديه علم بأن الدالة myFunction() موجودة فعلاً.
",,,,,,"#include <iostream>

using namespace std;

// حتى يقوم المترجم بالتعرف عليها و نصبح قادرين على استخدامها myFunction الدالة ( Declartion ) هنا قمنا بوضع تعريف
void myFunction();

int main()
{
	// myFunction() هنا قمنا باستدعاء الدالة
    myFunction();

    return 0;
}

// أو بمعنى آخر تعريف ما سيحدث عندما يتم استدعاءها ,myFunction الدالة ( body ) هنا قمنا بتعريف جسم
void myFunction()
{
    cout << ""My first function is called"";
}
		","في الدالة main() سيتم استدعاء و تتنفذ الدالة myFunction() بدون أي مشاكل و سنحصل على النتيجة التالية عند التشغيل.
My first function is called
",,,
الدوال,أين يجب تعريف الدوال,أين يجب تعريف الدوال,المثال الثالث,"المثال التالي يريك فقط كيف تقوم بترتيب الكود إذا كنت تنوي تعريف العديد من الدوال في الملف.
",,,,,,"#include <iostream>

using namespace std;

// نقوم بذكر تعريف جميع الدوال التي سنقوم بإنشائها لاحقاً main() قبل الدالة
void printMessage();
void greeting(string name);

// و فيها يمكننا استدعاء أي دالة قمنا بذكر تعريفها سابقاً بدون أي مشاكل main() هنا نقوم بتعريف الدالة
int main()
{
	// greeting() و printMessage() هنا يمكننا استدعاء
    return 0;
}

// لأنه قمنا بذكر أنها موجودة من قبل printMessage() هنا نقوم بتعريف الدالة
void printMessage()
{
   // هنا نكتب ما سيحدث عند استدعاءها	
}

// لأنه قمنا بذكر أنها موجودة من قبل greeting() هنا نقوم بتعريف الدالة
void greeting(string name)
{
   // هنا نكتب ما سيحدث عند استدعاءها	
}
		",,,,
الدوال,أخطاء قد تظهر بسبب وضع قيم إفتراضية للباراميترات,أخطاء قد تظهر بسبب وضع قيم إفتراضية للباراميترات,,"في جميع الأمثلة, سنفترض أننا نريد تعريف دالة و في كل مرة نحاول تمرير قيم إفتراضية لبعض عناصرها.
",,,,,,,,,,
الدوال,أخطاء قد تظهر بسبب وضع قيم إفتراضية للباراميترات,أخطاء قد تظهر بسبب وضع قيم إفتراضية للباراميترات,الخطأ الأول,"في المثال التالي قمنا بإعطاء c قيمة إفتراضية و هذا لن يسبب مشكلة لأنه لا يوجد بعده أي باراميتر.
",,,"void printMax(int a, int b, int c=0)
{
	
}
	",,,,,,,
الدوال,أخطاء قد تظهر بسبب وضع قيم إفتراضية للباراميترات,أخطاء قد تظهر بسبب وضع قيم إفتراضية للباراميترات,الخطأ الثاني,"المثال التالي فيه مشكلة حيث أننا قمنا بإعطاء b قيمة إفتراضية و لم نعطي قيمة إفتراضية للباراميتر c الموجود بعده.
	هذا الأمر سيؤدي لظهور مشكلة عند تشغيل الكود.
هذه الدالة ستسبب الخطأ التالي في الكود و الذي يعني أن المشكلة هي نسيان وضع قيمة إفتراضية للباراميتر الثالث.
",,,"void printMax(int a, int b=0, int c) 
{
	
}
	",,,,,,,
الدوال,أخطاء قد تظهر بسبب وضع قيم إفتراضية للباراميترات,أخطاء قد تظهر بسبب وضع قيم إفتراضية للباراميترات,الخطأ الثالث,"في المثال التالي قمنا بإعطاء b و c قيم إفتراضية و هذا لن يسبب مشكلة لأنه لا يوجد بعدهما أي باراميتر.
",,,"void printMax(int a, int b=0, int c=0) 
{
	
}
	",,,,,,,
الدوال,أخطاء قد تظهر بسبب وضع قيم إفتراضية للباراميترات,أخطاء قد تظهر بسبب وضع قيم إفتراضية للباراميترات,الخطأ الرابع,"المثال التالي فيه مشكلة حيث أننا قمنا بإعطاء a قمية إفتراضية و لم نعطي قيمة إفتراضية للباراميترين b و c الموجودين بعده.
	هذا الأمر سيؤدي لظهور مشكلة عند تشغيل الكود.
هذه الدالة ستسبب الخطأ التالي في الكود و الذي يعني أن المشكلة هي نسيان وضع قيمة إفتراضية للباراميترين الثاني و الثالث.
",,,"void printMax(int a=0, int b, int c) 
{
	
}
	",,,,,,,
الدوال,أخطاء قد تظهر بسبب وضع قيم إفتراضية للباراميترات,أخطاء قد تظهر بسبب وضع قيم إفتراضية للباراميترات,الخطأ الخامس,"في المثال التالي قمنا بإعطاء a و b و c قيم إفتراضية, أي كل البارميترات و بالتالي لا يوجد أي مشكلة هنا.
",,,"void printMax(int a=0, int b=0, int c=0) 
{
	
}
	",,,,,,,
الشروط,مفهوم الشروط,مفهوم الشروط,,"الشروط ( conditions ) تستخدم لتحديد طريقة عمل البرنامج نسبةً للمتغيرات التي تطرأ على الكود.
	كمثال بسيط, يمكنك بناء برنامج لمشاهدة الأفلام, عند الدخول إليه يطلب من المستخدم في البداية أن يدخل عمره لكي يقوم بعرض أقلام تناسب عمره.
يمكنك وضع العدد الذي تريده من الشروط في البرنامج الواحد, و تستطيع وضع الشروط بداخل بعضها البعض أيضاً.
",,,,,,,,,,
الشروط,جمل الشرط بشكل عام,جمل الشرط بشكل عام,,"الشكل العام لوضع الشروط هو التالي.
","ملاحظة
لست بحاجة إلى إستخدام الجمل الثلاثة في كل شرط تضعه في البرنامج, و لكنك مجبر على إستخدام جملة الشرط if مع أي شرط.
تابع كل الدرس حتى تتعرف على جميع طرق وضع الشروط.",,"if ( condition )
   {
       // إذا كان الشرط صحيحاً نفذ هذا الكود
   }
   else if ( condition )
   {
       // إذا كان الشرط صحيحاً نفذ هذا الكود
   }
   else
   {
       // نفذ هذا الكود في حال لم يتم التعرف على الكود في أي شرط
   }
",,,,,,,
الشروط,جملة الشرط if,جملة الشرط if,,"if في اللغة العربية تعني "" إذا "", و هي تستخدم فقط في حال كنت تريد تنفيذ كود معين حسب شرط معين.
",,,,,"إذا كانت قيمة المتغير S أكبر من 5 سيتم طباعة الجملة:   S is bigger than 5.
","#include <iostream>
using namespace std;

int main()
{
    int S = 0;
 
    if( S > 5 )
    {
        cout << ""S is bigger than 5"";
    }

    return 0;
}","        

","هنا سأل نفسه التالي: هل قيمة المتغير S أكبر من 5؟
فكان جواب الشرط كلا ( false ) , لذلك لم ينفذ أمر الطباعة الموجود في جملة الشرط.",,
الشروط,جملة الشرط if,جملة الشرط if,,,,,,,"إذا كانت قيمة المتغير S أكبر من 5 سيتم طباعة الجملة:   S is bigger than 5.
","#include <iostream>
using namespace std;

int main()
{
    int S = 30;
 
    if( S > 5 )
	{
        cout << ""S is bigger than 5"";
    }

    return 0;
}
		","S is bigger than 5

","هنا سأل نفسه التالي: هل قيمة المتغير S أكبر من 5؟
  فكان جواب الشرط نعم (true), لذلك نفذ أمر الطباعة الموجود في جملة الشرط.",,
الشروط,جملة الشرط if,وضع أكثر من شرط في الجملة if,,"بإمكانك أن تضع أكثر من شرط بداخل جملة الشرط باستخدام العامل && أو ||.
	العامل && يستخدم في حال كنت تريد تنفيذ كود معين إذا كان جواب جميع الشروط الموضوعة يساوي true.
	العامل || يستخدم في حال كنت تريد تنفيذ كود معين إذا كان جواب شرط واحد على الأقل يساوي true.",,,,,"إذا كانت قيمة المتغير a بين 0 و 20 إطبع الجملة:   acceptable number.
","#include <iostream>
using namespace std;

int main()
{
    int a = 14;
 
    if( a >= 0 && a <=20 )
	{
        cout << ""acceptable number"";
    }

    return 0;
}
		","acceptable number

","نلاحظ أنه قد تم تنفيذ أمر الطباعة لأن قيمة المتغير a بين 0 و 20.
هنا سأل نفسه سؤالين.
السؤال الأول: هل قيمة المتغير a أكبر أو تساوي 0؟
  فكان جواب الشرط الأول true.
السؤال الثاني: هل قيمة المتغير a أصغر أو تساوي 20؟
  فكان جواب الشرط الثاني أيضاً true.
بما أن كلا الجوابين كانا true قام بتنفيذ أمر الطباعة.
",,
الشروط,جملة الشرط if,وضع أكثر من شرط في الجملة if,,,,,,,"إذا كانت قيمة المتغير a بين 0 و 20 إطبع الجملة:   acceptable number.
","#include <iostream>
using namespace std;

int main()
{
    int a = 26;
 
    if( a >= 0 && a <=20 )
	{
        cout << ""acceptable number"";
    }

    return 0;
}
		"," 


","نلاحظ أنه لم يتم تنفيذ أمر الطباعة لأن قيمة المتغير a ليست بين 0 و 20.
هنا سأل نفسه سؤالين.
السؤال الأول: هل قيمة المتغير a أكبر أو تساوي 0؟
  فكان جواب الشرط الأول true.
السؤال الثاني: هل قيمة المتغير a أصغر أو تساوي 20؟
  فكان جواب الشرط الثاني false.
بما أن واحداً من الجوابين لم يكن true لم ينفذ دالة الطباعة.",,
الشروط,جملة الشرط if,وضع أكثر من شرط في الجملة if,المثال الثاني,,,,,,"إذا كانت قيمة المتغير a تساوي 1 أو 2 أو 3 إطبع الجملة:   you choose a valid number.
","#include <iostream>
using namespace std;

int main()
{
    int a = 2;
 
    if( a == 1 || a == 2 || a == 3 )
	{
        cout << ""'a' is a valid number"";
    }

    return 0;
}
		","a' is a valid number
",,,
الشروط,جملة الشرط else,جملة الشرط else,,"else في اللغة العربية تعني "" أي شيء آخر "", و هي تستخدم فقط في حال كنا نريد تنفيذ كود معين في حال كانت نتيجة جميع الشروط التي قبلها تساوي false.
يجب وضعها دائماً في الأخير, لأنها تستخدم في حال لم يتم تنفيذ أي جملة شرطية قبلها.
إذاً, إذا نفذ البرنامج الجملة if أو else if فإنه سيتجاهل الجملة else.
	و إذا لم ينفذ أي جملة من الجمل if و else if فإنه سينفذ الجملة else.
",,,,,"إذا كانت قيمة المتغير S تساوي 5 سيتم طباعة الجملة:   S is equal 5.
إذا كانت قيمة المتغير S لا تساوي 5 سيتم طباعة الجملة:   S is not equal 5.
","#include <iostream>
using namespace std;

int main()
{
    int S = 5;
 
    if( S == 5 )
    {
        cout << ""S is equal 5"";
    }
    
    else
    {
        cout << ""S is not equal 5"";
    }

    return 0;
}",S is equal 5,"هنا سأل نفسه التالي: هل قيمة المتغير S تساوي 5؟
فكان جواب الشرط نعم ( true ) , لذلك نفذ أمر الطباعة الموجود في الجملة if.",,
الشروط,جملة الشرط else,جملة الشرط else,,,,,,,"إذا كانت قيمة المتغير S تساوي 5 سيتم طباعة الجملة:   S is equal 5.
إذا كانت قيمة المتغير S لا تساوي 5 سيتم طباعة الجملة:   S is not equal 5.
","#include <iostream>
using namespace std;

int main()
{
    int S = 20;
 
    if( S == 5 )
	{
        cout << ""S is equal 5"";
    }
	
    else
	{
        cout << ""S is not equal 5"";
    }

    return 0;
}
		","S is not equal 5
","هنا سأل نفسه التالي: هل قيمة المتغير S تساوي 5؟
فكان جواب الشرط كلا ( false ) , لذلك نفذ أمر الطباعة الموجود في الجملة else.",,
الشروط,جملة الشرط else if,جملة الشرط else if,,"جملة else if تستخدم إذا كنت تريد وضع أكثر من إحتمال ( أي أكثر من شرط ).
جملة أو جمل الـ else if يوضعون في الوسط, أي بين الجملتين if و else.
",,,,,"إذا كانت قيمة المتغير number تساوي 1 سيتم طباعة الكلمة:   one.
	    •إذا كانت قيمة المتغير number تساوي 2 سيتم طباعة الكلمة:   two.
	    •إذا كانت قيمة المتغير number تساوي 3 سيتم طباعة الكلمة:   three.
	    •إذا كانت قيمة المتغير number أكبر أو تساوي 4 سيتم طباعة الجملة:   four or greater.
	    •إذا كانت قيمة المتغير number أصغر من 0 سيتم طباعة الجملة:   negative number.
","#include <iostream>
using namespace std;

int main()
{
    int number = 3;
 
    if( number == 1 )
	{
        cout << ""one"";
    }
 
    else if( number == 2 )
	{
        cout << ""two"";
    }
 
    else if( number == 3 )
	{
        cout << ""three"";
    }
 
    else if( number >= 4 )
	{
        cout << ""four or greater"";
    }
 
    else
	{
        cout << ""negative number"";
    }
 
    return 0;
}
		","three

",,,"فكان جواب الشرط كلا ( false ) , لذلك نفذ أمر الطباعة الموجود في الجملة else."
الشروط,جملة الشرط else if,شرط بداخل شرط,,"نستطيع وضع الشروط بداخل بعضها, و يمكننا وضع العدد الذي نريده من الشروط.
	في البرامج الفعلية يقوم المبرمج بوضع العديد من الشروط بداخل بعضها, و ذلك حسب الفكرة التي يريد تنفيذها في برنامجه.",,,,,"هنا قمنا بتجهيز متغير يمثل نوع الجنس إسمه isMale و قلنا إذا كانت قيمته true فهذا يعني أن الشخص هو ذكر.
		و إذا كانت تساوي false فهذا يعني أن الشخص هو أنثى.
بالإضافة لمتغير يمثل العمر إسمه age.
","#include <iostream>
using namespace std;

int main()
{
    bool isMale = false;
    int age = 14;
 
    if( isMale == true )
    {
        cout << ""Gender: male"";
		
        if( age <= 21 )
		{
            cout << ""\nHe is a young boy"";
        }
    }
 
    else
    {
        cout << ""Gender: female"";
		
        if( age <= 21 )
		{
            cout << ""\nShe is a young girl"";
        }
    }

    return 0;
}
		","Gender: female
She is a young girl

",,,
الشروط,الجملة switch,تعريف الجملة switch,,"switch نستخدمها إذا كنا نريد إختبار قيمة متغير معين مع لائحة من الإحتمالات نقوم نحن بوضعها, و إذا تساوت هذه القيمة مع أي إحتمال وضعناه ستتنفذ الأوامر التي وضعناها في هذا الإحتمال فقط.
كل إحتمال نضعه يسمى case.
أنواع المتغيرات التي يمكن إختبار قيمتها باستخدام هذه الجملة هي:
	int - byte - short - char - enum.",,,"
switch(expression) {
       case value:
           // Statements
           break;
       case value:
           // Statements
           break;
       default:
           // Statements
           break;}","
يمكننا تعريفها بعدة أشكال, الشكل الأساسي هو التالي:",,,,,,
الشروط,الجملة switch,تعريف الجملة switch,,"switch تعني إختبر قيمة المتغير الموضوع بين قوسين.
		
expression هنا يقصد بها المتغير الذي نريد إختبار قيمته.
		نوع المتغير الذي يسمح لنا بإختباره: int - byte - short - char - String - enum.
		
case تعني حالة, value تعني قيمة, و Statements تعني أوامر.
		و يقصد من هذا كله, أنه في حال كانت قيمة الـ expression تساوي هذه القيمة سيقوم بتنفيذ الأوامر الموضوعة بعد النقطتين :.
		الآن بعد تنفيذ جميع الأوامر الموضوعة بعد النقطتين, يجب وضع break لكي يخرج من الجملة switch مباشرةً بدل أن ينتقل للـ case التالية الموجودة في الجملة switch.
		نستطيع وضع العدد الذي نريده من الـ case بداخل الجملة switch.
		إنتبه: الـ expression و الـ value يجب أن يكونا من نفس النوع.
		
	    default تعني إفتراضياً و هي نفس فكرة الجملة else, و يمكننا أن لا نضعها أيضاً.
		هذه الجملة تنفذ فقط في حال لم تنفذ أي case موجودة في الجملة switch و لذلك نضعها بالآخر.
ستفهم فكرة الجملة switch من خلال الأمثلة و سنريك كيف يمكنك أن تنفذ نفس الأوامر لأكثر من حالة, من خلال الأمثلة.
","ملاحظة
لا حاجة لوضع break للحالة الأخيرة لأن البرنامج سيخرج من الجملة switch في جميع الأحوال.",,,,,,,,,
الشروط,الجملة switch,أمثلة على الجملة switch,,"ستفهم فكرة الجملة switch من خلال الأمثلة و سنريك كيف يمكنك أن تنفذ نفس الأوامر لأكثر من حالة, من خلال الأمثلة.",,,,,"سنقوم باختبار قيمة المتغير x و الذي نوعه int.
سنضع عدة حالات و كل حالة تطبع شيء معين.
","#include <iostream>
using namespace std;

int main()
{
    int x = 2;
 
    switch( x )   // x إختبر قيمة المتغير
    {
        case 1:   // في حال كانت تساوي 1 سيتم تنفيذ أمر الطباعة الموضوع فيها
            cout << ""x contain 1"";
            break;
 
        case 2:   // في حال كانت تساوي 2 سيتم تنفيذ أمر الطباعة الموضوع فيها
            cout << ""x contain 2"";
            break;
 
        case 3:   // في حال كانت تساوي 3 سيتم تنفيذ أمر الطباعة الموضوع فيها
            cout << ""x contain 3"";
            break;
 
        default:   // في حال كانت لا تساوي أي قيمة من القيم الموضوعة سيتم تنفيذ أمر الطباعة الموضوع فيها
            cout << ""x contain a different value"";
    }

    return 0;
}","x contain 2
","نلاحظ أنه تم تنفيذ أمر الطباعة الموجود في الحالة الثانية لأن قيمة المتغير x تساوي 2.

هنا سأل نفسه التالي: هل قيمة المتغير x تساوي 1؟
فكان جواب الشرط كلا ( false ), فانتقل إلى الحالة التي تليه.

ثم سأل نفسه التالي: هل قيمة المتغير x تساوي 2؟
فكان جواب الشرط نعم ( true ), فقام بتنفيذ أمر الطباعة الموجود في هذه الحالة, و بعدها خرج من جملة الـ switch بأكملها بسبب الجملة break.",,
الشروط,الجملة switch,أمثلة على الجملة switch,المثال الثاني,,,,,,"سنقوم باختبار قيمة المتغير x و الذي نوعه int.
سنضع عدة حالات و كل حالة تطبع شيء معين.
","#include <iostream>
using namespace std;

int main()
{
    int x = 5;
 
    switch( x )   // x إختبر قيمة المتغير
	{
        case 1:   // في حال كانت تساوي 1 سيتم تنفيذ أمر الطباعة الموضوع فيها
            cout << ""x contain 1"";
            break;
 
        case 2:   // في حال كانت تساوي 2 سيتم تنفيذ أمر الطباعة الموضوع فيها
            cout << ""x contain 2"";
            break;
 
        case 3:   // في حال كانت تساوي 3 سيتم تنفيذ أمر الطباعة الموضوع فيها
            cout << ""x contain 3"";
            break;
 
        default:   // في حال كانت لا تساوي أي قيمة من القيم الموضوعة سيتم تنفيذ أمر الطباعة الموضوع فيها
            cout << ""x contain a different value"";
    }

    return 0;
}
		","x contain a different value

","نلاحظ أن تم تنفيذ أمر الطباعة الموجود في الحالة الإفتراضية لأن قيمة المتغير x لا تساوي أي قيمة من القيم الموضوعة في الحالات.
هنا سأل نفسه التالي: هل قيمة المتغير x تساوي 1؟
  فكان جواب الشرط كلا ( false ), فانتقل إلى الحالة التي تليه.
ثم سأل نفسه التالي: هل قيمة المتغير x تساوي 2؟
  فكان جواب الشرط كلا ( false ), فانتقل إلى الحالة التي تليه.
ثم سأل نفسه التالي: هل قيمة المتغير x تساوي 3؟
  فكان جواب الشرط كلا ( false ), فانتقل إلى الحالة التي تليه.
بما أنه لم يجد أي حالة تساوت فيها القيمة مع قيمة المتغير الذي يتم اختباره, قام بتنفيذ الأوامر الموجودة في الحالة الإفتراضية default, وعندما إنتهى من تنفيذ الأوامر خرج من جملة الـ switch بأكملها.",,
الشروط,الجملة switch,وضع نفس الأوامر لأكثر من حالة,,"إذا أردت وضع نفس الأوامر لأكثر من حالة, عليك وضع الحالات تحت بعضها, ثم كتابة الأوامر, ثم وضع break.
",,,,,"سنقوم باختبار قيمة المتغير x و الذي نوعه int.
سنضع ثلاث حالات ينفذون نفس الأوامر.
","#include <iostream>
using namespace std;

int main()
{
    int x = 3;
 
    switch( x )     // x إختبر قيمة المتغير
	{
        case 1:     // في حال كانت تساوي 1 أو 2 أو 3 سيتم تنفيذ أمر الطباعة
        case 2:
        case 3:
            cout << ""x contain 1 or 2 or 3"";
            break;
 
        default:    // في حال كانت لا تساوي أي قيمة من القيم الموضوعة سيتم تنفيذ أمر الطباعة الموضوع فيها
            cout << ""x contain a different value"";
    }

    return 0;
}
		","x contain 1 or 2 or 3

","نلاحظ أنه تم تنفيذ أمر الطباعة الموضوع للحالات الثلاث الأولى لأن قيمة x تساوي 3.
هنا سأل نفسه التالي: هل قيمة المتغير x تساوي 1 أو 2 أو 3؟
  فكان جواب الشرط نعم ( true ), فقام بتنفيذ أمر الطباعة الموضوع لهذه الحالات الثلاث, و بعدها خرج من جملة الـ switch بأكملها بسبب الجملة break.",,
الشروط,الجملة switch,وضع أكثر من إحتمال باستخدام العامل ...,,"إذا كان لديك سلسلة من الإحتمالات تريد وضع نفس الأوامر عليها, يمكنك استخدام العامل ....
",,,,,"سنقوم باختبار قيمة المتغير x و الذي نوعه int.
سنضع 100 حالة ينفذون نفس الأوامر باستخدام case واحدة.
","#include <iostream>
using namespace std;

int main()
{
    int x = 40;
 
    switch( x )     // x إختبر قيمة المتغير
	{
        case 1 ... 100:     // في حال كانت تساوي أي عدد صحيح موجود بين 1 و 100 سيتم تنفيذ أمر الطباعة
            cout << ""x contain "" <<  x;
            break;
 
        default:    // في حال كانت لا تساوي أي قيمة من القيم الموضوعة سيتم تنفيذ أمر الطباعة الموضوع فيها
            cout << ""x contain a different value"";
    }

    return 0;
}
		","x contain 40

","نلاحظ أنه تم تنفيذ أمر الطباعة الموضوع للحالة الأولى لأن قيمة x موجودة بين 1 و 100.
هنا سأل نفسه التالي: هل قيمة المتغير x تساوي 1 أو 2 إلخ.. حتى وصل إلى 40 فكان جواب الشرط نعم ( true ), لهذا قام بتنفيذ أمر الطباعة الموضوع لكل الحالات الموجودة بين 1 و 100 و بعدها خرج من جملة الـ switch بأكملها بسبب الجملة break.",,
العوامل,مفهوم العوامل,مفهوم العوامل,,"العوامل ( operators ) عبارة عن رموز لها معنى محدد, و يمكننا تقسيم العوامل إلى 5 مجموعات أساسية كالتالي:

	    Arithmetic Operators
	    Comparison Operators
	    Logical Operators
	    Bitwise Operators
	    Assignment Operators
	

هناك أيضاً عوامل أخرى, سنراها في آخر القسم.
",,,,,,,,,,
العوامل,العوامل التي تستخدم في العمليات الحسابية,العامل = (Assignment Operator),,"العامل = يستخدم لإعطاء قيمة للمتغير.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
    int a = 5;     // 5 القيمة a أعطينا المتغير
    int b = a;     // a قيمة المتغير b أعطينا المتغير

    cout << ""a = "" << a << endl;
    cout << ""b = "" << b;

    return 0;
}
		","a = 5
b = 5
",,,
العوامل,العوامل التي تستخدم في العمليات الحسابية,العامل + (Addition Operator),,"العامل + يستخدم لإضافة قيمة على قيمة, أي في عمليات الجمع.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
    int a = 3;
    int b = 4;
 
    int c = a + b;   // c = 3 + 4 = 7
 
    cout << ""c = "" << c;

    return 0;
}
		",c = 7,,,
العوامل,العوامل التي تستخدم في العمليات الحسابية,العامل - (Subtraction Operator),,"العامل - يستخدم لإنقاص قيمة من قيمة, أي في عمليات الطرح.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
    int a = 3;
    int b = 4;

    int c = a - b;   // c = 3 - 4 = -1

    cout << ""c = "" << c;

    return 0;
}
		","c = -1
",,,
العوامل,العوامل التي تستخدم في العمليات الحسابية,العامل + (Unary-Plus Operator),,"يعني ضرب القيمة بالعامل +.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
    // b لها في المتغير Unary-Plus قيمة أكبر من صفر, ثم وضعنا قيمة الـ a هنا وضعنا في المتغير
    int a = 10;
    int b = +a;        // b = +(10) = 10

    cout << ""b = "" << b << endl;

    // b لها في المتغير Unary-Plus قيمة أصغر من صفر, ثم وضعنا قيمة الـ a هنا وضعنا في المتغير
    a = -10;
    b = +a;           // b = +(-10) = -10

    cout << ""b = "" << b;

    return 0;
}
		","b = 10
b = -10
",,,
العوامل,العوامل التي تستخدم في العمليات الحسابية,العامل - (Unary-Minus Operator),,"يعني ضرب القيمة بالعامل -.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
    // b لها في المتغير Unary-Minus قيمة أكبر من صفر, ثم وضعنا قيمة الـ a هنا وضعنا في المتغير
    int a = 10;
    int b = -a;        // b = -(10) = -10

    cout << ""b = "" << b << endl;

    // b لها في المتغير Unary-Minus قيمة أصغر من صفر, ثم وضعنا قيمة الـ a هنا وضعنا في المتغير
    a = -10;
    b = -a;           // b = -(-10) = 10

    cout << ""b = "" << b;

    return 0;
}
		","b = -10
b = 10
",,,
العوامل,العوامل التي تستخدم في العمليات الحسابية,العامل * (Multiplication Operator),,"العامل * يستخدم لضرب قيمة بقيمة, أي في عمليات الضرب.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
    int a = 6;
    int b = 5;
 
    int c = a * b;     // c = 6 * 5 = 30
 
    cout << ""c = "" << c;

    return 0;
}
		","c = 30
",,,
العوامل,العوامل التي تستخدم في العمليات الحسابية,العامل / (Division Operator),,"العامل / يستخدم لقسمة قيمة على قيمة, أي في عمليات القسمة.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
    int a = 8;
    int b = 5;
    
    int c = a / b;     // c = 8 / 5 = 1
    
    cout << ""c = "" << c;

    return 0;
}
		","c = 1

",ملاحظة: سبب عدم ظهور أي أرقام بعد الفاصلة هو أننا عرفنا المتغيرات كأعداد صحيحة int.,,
العوامل,العوامل التي تستخدم في العمليات الحسابية,العامل % (Modulo Operator),,"العامل % يقال له الـ Modulo و يسمى Remainder في الرياضيات و هو آخر رقم يبقى من عملية القسمة.
	إذاً نستخدم الـ Modulo للحصول على آخر رقم يبقى من عملية القسمة.
	و له فوائد كثيرة, فمثلاً يمكننا إستخدامه لمعرفة ما إذا كان الرقم مفرد أو مزدوج ( أي Even or Odd ) و هذا شرحناه بتفصيل في مادة الخوارزميات.
",,,,,"في هذا المثال سنقوم بتخزين الرقم الذي يبقى من القسمة في المتغير c.
","#include <iostream>
using namespace std;

int main()
{
    int a = 8;
    int b = 5;

    int c = a % b;     // c = 8 % 5 = 3

    cout << ""c = "" << c;

    return 0;
}
		","c = 3
",,,
العوامل,العوامل التي تستخدم في العمليات الحسابية,العامل ++ (Increment Operator),,"العامل ++ يستخدم لزيادة قيمة المتغير واحداً, و هذا الأسلوب يستخدم كثيراً في الحلقات لزيادة قيمة العداد واحداً في كل دورة بكود أقل.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
    int a = 5;
    
    a++;     // a = 5 + 1 = 6
    
    cout << ""a = "" << a;

    return 0;
}
		","a = 6
",,,
العوامل,العوامل التي تستخدم في العمليات الحسابية,العامل -- (Decrement Operator),,"العامل -- يستخدم لإنقاص قيمة المتغير واحداً, و هذا الأسلوب يستخدم كثيراً في الحلقات لإنقاص قيمة العداد واحداً في كل دورة بكود أقل.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
    int a = 5;
 
    a--;     // a = 5 - 1 = 4
 
    cout << ""a = "" << a;

    return 0;
}
		","a = 4
",,,
العوامل,العوامل التي تستخدم للمقارنة,العامل == (Equal To Operator),,"العامل == يستخدم لتنفيذ كود معين إذا كانت قيمة المتغير الأول تساوي قيمة المتغير الثاني.
عندما نضعه في الشرط فإنه يعني هل قيمة المتغير الأول تساوي قيمة المتغير الثاني؟
إذا كانت  تساويها سيكون الجواب true و بالتالي سينفذ الكود.
		أما إذا لم تكن تساويها سيكون الجواب false و بالتالي لن ينفذ الكود.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
	int a = 10;
	int b = 10;
	int c = 20;
	
	// سيتم تنفيذ أمر الطباعة b تساوي قيمة المتغير a الشرط التالي يعني أنه إذا كانت قيمة المتغير
	if( a == b )
	{
		cout << ""a = b"";
	}
	
	// سيتم تنفيذ أمر الطباعة c تساوي قيمة المتغير a الشرط التالي يعني أنه إذا كانت قيمة المتغير
	if( a == c )
	{
		cout << ""a = c"";
	}

    return 0;
}
		","a = b

","نلاحظ أنه نفذ أمر الطباعة الموضوع في الشرط الأول لأن جواب الشرط كان true.
 لم ينفذ أمر الطباعة الموضوع في الشرط الثاني لأن جواب الشرط كان false.",,
العوامل,العوامل التي تستخدم للمقارنة,العامل != (Not Equal To Operator),,"العامل != يستخدم لتنفيذ كود معين إذا كانت قيمة المتغير الأول لا تساوي قيمة المتغير الثاني.
عندما نضعه في الشرط فإنه يعني هل قيمة المتغير الأول لا تساوي قيمة المتغير الثاني؟
إذا كانت  لا تساويها سيكون الجواب true و بالتالي سينفذ الكود.
		أما إذا كانت تساويها سيكون الجواب false و بالتالي لن ينفذ الكود.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
    int a = 10;
    int b = 10;
    int c = 20;
 
    // سيتم تنفيذ أمر الطباعة b لا تساوي قيمة المتغير a الشرط التالي يعني أنه إذا كانت قيمة المتغير
    if( a != b )
    {
        cout << ""a != b"";
    }
 
    // سيتم تنفيذ أمر الطباعة c لا تساوي قيمة المتغير a الشرط التالي يعني أنه إذا كانت قيمة المتغير
    if( a != c )
    {
        cout << ""a != c"";
    }

    return 0;
}
		","a != c

","نلاحظ أنه نفذ أمر الطباعة الموضوع في الشرط الثاني لأن جواب الشرط كان true.
  •لم ينفذ أمر الطباعة الموضوع في الشرط الأول لأن جواب الشرط كان false.",,
العوامل,العوامل التي تستخدم للمقارنة,العامل > (Greater Than Operator),,"العامل > يستخدم لتنفيذ كود معين إذا كانت قيمة المتغير الأول أكبر من قيمة المتغير الثاني.
عندما نضعه في الشرط فإنه يعني هل قيمة المتغير الأول أكبر من قيمة المتغير الثاني؟
إذا كانت  أكبر منها سيكون الجواب true و بالتالي سينفذ الكود.
		إذا لم تكن أكبر منها سيكون الجواب false و بالتالي لن ينفذ الكود.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
    int a = 10;
    int b = 5;
 
    // سيتم تنفيذ أمر الطباعة b أكبر من قيمة المتغير a الشرط التالي يعني أنه إذا كانت قيمة المتغير
    if( a > b )
    {
        cout << ""a > b"";
    }
 
    // سيتم تنفيذ أمر الطباعة a أكبر من قيمة المتغير b الشرط التالي يعني أنه إذا كانت قيمة المتغير
    if( b > a )
    {
        cout << ""b > a"";
    }

    return 0;
}
		","a > b

","نلاحظ أنه نفذ أمر الطباعة الموضوع في الشرط الأول لأن جواب الشرط كان true.
  •لم ينفذ أمر الطباعة الموضوع في الشرط الثاني لأن جواب الشرط كان false.",,
العوامل,العوامل التي تستخدم للمقارنة,العامل < (Less Than Operator),,"العامل < يستخدم لتنفيذ كود معين إذا كانت قيمة المتغير الأول أصغر من قيمة المتغير الثاني.
عندما نضعه في الشرط فإنه يعني هل قيمة المتغير الأول أصغر من قيمة المتغير الثاني؟
إذا كانت  أصغر منها سيكون الجواب true و بالتالي سينفذ الكود.
		إذا لم تكن أصغر منها سيكون الجواب false و بالتالي لن ينفذ الكود.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
    int a = 10;
    int b = 5;
 
    // سيتم تنفيذ أمر الطباعة b أصغر من قيمة المتغير a الشرط التالي يعني أنه إذا كانت قيمة المتغير
    if( a < b )
    {
        cout << ""a < b"";
    }
 
    // سيتم تنفيذ أمر الطباعة a أصغر من قيمة المتغير b الشرط التالي يعني أنه إذا كانت قيمة المتغير
    if( b < a )
    {
        cout << ""b < a"";
    }

    return 0;
}
		","b < a

","نلاحظ أنه نفذ أمر الطباعة الموضوع في الشرط الثاني لأن جواب الشرط كان true.
  •لم ينفذ أمر الطباعة الموضوع في الشرط الأول لأن جواب الشرط كان false.",,
العوامل,العوامل التي تستخدم للمقارنة,العامل >= (Greater Than or Equal To Operator),,"العامل >= يستخدم لتنفيذ كود معين إذا كانت قيمة المتغير الأول أكبر أو تساوي قيمة المتغير الثاني.
عندما نضعه في الشرط فإنه يعني هل قيمة المتغير الأول أكبر أو تساوي قيمة المتغير الثاني؟
إذا كانت أكبر منها أو تساويها سيكون الجواب true و بالتالي سينفذ الكود.
		إذا لم تكن أكبر منها أو تساويها سيكون الجواب false و بالتالي لن ينفذ الكود.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
    int a = 5;
    int b = 5;
    int c = 10;
 
    // سيتم تنفيذ أمر الطباعة b أكبر أو تساوي قيمة المتغير a الشرط التالي يعني أنه إذا كانت قيمة المتغير
    if( a >= b )
    {
        cout << ""a >= b"" << endl;
    }
 
    // سيتم تنفيذ أمر الطباعة c أكبر أو تساوي قيمة المتغير a الشرط التالي يعني أنه إذا كانت قيمة المتغير
    if( a >= c )
    {
        cout << ""a >= c"" << endl;
    }
 
    // سيتم تنفيذ أمر الطباعة a أكبر أو تساوي قيمة المتغير c الشرط التالي يعني أنه إذا كانت قيمة المتغير
    if( c >= a )
    {
        cout << ""c >= a"" << endl;
    }

    return 0;
}
		","a >= b
c >= a

","نلاحظ أنه نفذ أمر الطباعة الموضوع في الشرط الأول و الثالث لأن جواب الشرط كان true.
  •لم ينفذ أمر الطباعة الموضوع في الشرط الثاني لأن جواب الشرط كان false.",,
العوامل,العوامل التي تستخدم للمقارنة,العامل <= (Less Than or Equal To Operator),,"العامل <= يستخدم لتنفيذ كود معين إذا كانت قيمة المتغير الأول أصغر أو تساوي قيمة المتغير الثاني.
عندما نضعه في الشرط فإنه يعني هل قيمة المتغير الأول أصغر أو تساوي قيمة المتغير الثاني؟
إذا كانت أصغر منها أو تساويها سيكون الجواب true و بالتالي سينفذ الكود.
		إذا لم تكن أصغر منها أو تساويها سيكون الجواب false و بالتالي لن ينفذ الكود.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
    int a = 5;
    int b = 5;
    int c = 10;
 
    // سيتم تنفيذ أمر الطباعة b أصغر أو تساوي قيمة المتغير a الشرط التالي يعني أنه إذا كانت قيمة المتغير
    if( a <= b )
    {
        cout << ""a <= b"" << endl;
    }
 
    // سيتم تنفيذ أمر الطباعة c أصغر أو تساوي قيمة المتغير a الشرط التالي يعني أنه إذا كانت قيمة المتغير
    if( a <= c )
    {
        cout << ""a <= c"" << endl;
    }
 
    // سيتم تنفيذ أمر الطباعة a أصغر أو تساوي قيمة المتغير c الشرط التالي يعني أنه إذا كانت قيمة المتغير
    if( c <= a )
    {
        cout << ""c <= a"" << endl;
    }

    return 0;
}
		","a <= b
a <= c

","نلاحظ أنه نفذ أمر الطباعة الموضوع في الشرط الأول و الثاني لأن جواب الشرط كان true.
  •لم ينفذ أمر الطباعة الموضوع في الشرط الثالث لأن جواب الشرط كان false.",,
العوامل,العوامل التي تستخدم لوضع شروط منطقية,العامل && (AND Operator),,"العامل && يستخدم لتنفيذ كود معين إذا تحقق الشرط الأول و الشرط الثاني.
أي إذا كانت  نتيجة الشرط الأول تساوي true و نتيجة الشرط الثاني تساوي true سينفذ الكود.
		إذا لم تكن نتيجة كلا الشرطين تساوي true لن ينفذ الكود.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
    int a = 10;
    int b = 20;
 
    // تساوي 20 سيتم تنفيذ أمر الطباعة b تساوي 10, و قيمة المتغير a الشرط التالي يعني أنه إذا كانت قيمة المتغير
    if( a == 10 && b == 20 )
    {
        cout << ""The first and the second conditions return true"";
    }

    return 0;
}
		","The first and the second conditions return true
","نلاحظ أنه نفذ أمر الطباعة لأن جواب الشرطين الموضوعين في الجملة if هو true.
",,
العوامل,العوامل التي تستخدم لوضع شروط منطقية,العامل && (AND Operator),,"العامل && يستخدم لتنفيذ كود معين إذا تحقق الشرط الأول و الشرط الثاني.
أي إذا كانت  نتيجة الشرط الأول تساوي true و نتيجة الشرط الثاني تساوي true سينفذ الكود.
		إذا لم تكن نتيجة كلا الشرطين تساوي true لن ينفذ الكود.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
    int a = 10;
    int b = 20;
 
    // تساوي 50 سيتم تنفيذ أمر الطباعة b تساوي 10, و قيمة المتغير a الشرط التالي يعني أنه إذا كانت قيمة المتغير
    if( a == 10 && b == 50 )
    {
        cout << ""The first and the second conditions return true"";
    }

    return 0;
}
		","

",نلاحظ أنه لم ينفذ أمر الطباعة لأن جواب الشرط الثاني الموضوع في الجملة if هو false.,,
العوامل,العوامل التي تستخدم لوضع شروط منطقية,العامل || (OR Operator),,"العامل || يستخدم لتنفيذ كود معين إذا تحقق على الأقل واحد من الشروط الموضوعة.
	إذاً هنا يكفي أن يرجع أحد الشرطين القيمة true حتى يتم تنفيذ الأوامر الموضوعة.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
    int a = 10;
    int b = 20;
 
    // تساوي 50 سيتم تنفيذ أمر الطباعة b تساوي 10, أو قيمة المتغير a الشرط التالي يعني أنه إذا كانت قيمة المتغير
    if( a == 10 || b == 50 )
    {
        cout << ""One of the conditions return true"";
    }

    return 0;
}
		","One of the conditions return true

",نفذ أمر الطباعة لأن جواب الشرط الأول الموضوع في الجملة if هو true.,,
العوامل,العوامل التي تستخدم لوضع شروط منطقية,العامل || (OR Operator),,"العامل || يستخدم لتنفيذ كود معين إذا تحقق على الأقل واحد من الشروط الموضوعة.
	إذاً هنا يكفي أن يرجع أحد الشرطين القيمة true حتى يتم تنفيذ الأوامر الموضوعة.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
    int a = 10;
    int b = 20;
 
    // تساوي 50 سيتم تنفيذ أمر الطباعة b تساوي 50, أو قيمة المتغير a الشرط التالي يعني أنه إذا كانت قيمة المتغير
    if( a == 50 || b == 50 )
    {
        cout << ""One of the conditions return true"";
    }

    return 0;
}
		"," 

",نلاحظ أنه لم ينفذ أمر الطباعة لأن جواب الشرط الأول و الثاني الموضوعين في الجملة if هو false.,,
العوامل,العوامل التي تستخدم لوضع شروط منطقية,العامل ! (NOT Operator),,"العامل ! يستخدم لتنفيذ كود معين إذا لم يتحقق أي شرط تم وضعه.
	أي إذا أرجع الشرط أو جميع الشروط الموضوعة القيمة false سيتم تنفيذ الأوامر الموضوعة.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
    int a = 10;
 
    // لا تساوي 10 سيتم تنفيذ أمر الطباعة a الشرط التالي يعني أنه إذا كانت قيمة المتغير
    if( !(a == 10) )
    {
        cout << ""The condition return false"";
    }

    return 0;
}
		","

 ",لم ينفذ أمر الطباعة لأن جواب الشرط هو true.,,
العوامل,العوامل التي تستخدم لوضع شروط منطقية,العامل ! (NOT Operator),,"العامل ! يستخدم لتنفيذ كود معين إذا لم يتحقق أي شرط تم وضعه.
	أي إذا أرجع الشرط أو جميع الشروط الموضوعة القيمة false سيتم تنفيذ الأوامر الموضوعة.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
    int a = 10;
 
    // لا تساوي 20 سيتم تنفيذ أمر الطباعة a الشرط التالي يعني أنه إذا كانت قيمة المتغير
    if( !(a == 20) )
    {
        cout << ""The condition return true"";
    }

    return 0;
}
		","The condition return true

",نفذ أمر الطباعة لأن جواب الشرط هو false.,,
العوامل,العوامل التي تستخدم للتعامل مع الـ Bits,العامل & (Bitwize AND),,"العامل & يحسب ناتج جمع الـ bits المشتركة بين قيمتين.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
    int a = 10;      // a = 10 = 00000000000000000000000000001010
    int b = 75;      // b = 75 = 00000000000000000000000001001011
 
    int c = a & b;   // شرحنا كيف سيتم الحصول على الناتج تحت نتيجة التشغيل
 
    cout << a << "" & "" << b << "" = "" << c;

    return 0;
}
		","10 & 75 = 10
","a = 10;         // 10 = 00000000000000000000000000001010
b = 75;         // 75 = 00000000000000000000000001001011
c = a & b;   //  c = 00000000000000000000000000001010
                    //  c = 10",,
العوامل,العوامل التي تستخدم للتعامل مع الـ Bits,العامل | (Bitwize OR),,"العامل | يحسب ناتج جمع الـ bits المشتركة و الغير مشتركة بين قيمتين.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
    int a = 10;      // 10 = 00000000000000000000000000001010
    int b = 75;      // 75 = 00000000000000000000000001001011
 
    int c = a | b;   // شرحنا كيف سيتم الحصول على الناتج تحت نتيجة التشغيل
 
    cout << a << "" | "" << b << "" = "" << c;

    return 0;
}
		",10 | 75 = 75,"a = 10;      // 10 = 00000000000000000000000000001010
b = 75;      // 75 = 00000000000000000000000001001011
c = a | b;   //  c = 00000000000000000000000001001011
                   //  c = 75
",,
العوامل,العوامل التي تستخدم للتعامل مع الـ Bits,العامل ^ (Bitwize XOR),,"العامل ^ يحسب ناتج جمع الـ bits الغير مشتركة بين قيمتين.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
    int a = 10;      // 10 = 00000000000000000000000000001010
    int b = 75;      // 75 = 00000000000000000000000001001011
 
    int c = a ^ b;   // شرحنا كيف سيتم الحصول على الناتج تحت نتيجة التشغيل
 
    cout << a << "" ^ "" << b << "" = "" << c;

    return 0;
}
		",10 ^ 75 = 65,"a = 10;      // 10 = 00000000000000000000000000001010
b = 75;      // 75 = 00000000000000000000000001001011
c = a | b;   //  c = 00000000000000000000000001000001
                 //  c = 65
",,
العوامل,العوامل التي تستخدم للتعامل مع الـ Bits,العامل ~ (Bitwize Compliment OR),,"العامل ~ يقلب الـ bits التي تساوي 0 إلى 1 و يقلب الـ bits التي تساوي 1 إلى 0.
	بعدها يتم حساب الناتج باتباع مبدأ single precision floating point number.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
    int a = 10;     // 10 = 00000000000000000000000000001010
    int c = ~a;     //  c = 11111111111111111111111111110111 = -11
 
    cout << ""~"" << a << "" = "" << c;

    return 0;
}
		","~10 = -11
",,,
العوامل,العوامل التي تستخدم للتعامل مع الـ Bits,العامل << (Left Shift),,"العامل << يمسح bits من ناحية اليسار ثم يبدل كل bit تم مسحها منهم بصفر و يضعهم من ناحية اليمين.
",,,,,"إذا كان العدد أكبر من صفر, يمسح bits من ناحية اليمين ثم يبدل كل bit منهم بصفر و يضعهم من ناحية اليسار.
		إذا كان العدد أصغر من صفر, يمسح bits من ناحية اليمين ثم يبدل كل bit منهم بواحد ليحافظ على إشارة الناقص و يضعهم من ناحية اليسار.
","#include <iostream>
using namespace std;

int main()
{
    int a = 10;       // 10 = 00000000000000000000000000001010
    int c = a << 2;   // شرحنا كيف سيتم الحصول على الناتج تحت نتيجة التشغيل
	
    cout << a << "" << 2 = "" << c;

    return 0;
}
		","10 << 2 = 40
","a = 10;       // 10 = 00000000000000000000000000001010
c = a << 2;   //  c = 00000000000000000000000000101000 = 40
                  //  c = 40",,
العوامل,العوامل التي تستخدم للتعامل مع الـ Bits,العامل >> (Right Shift),,"العامل >> عندها حالتين: قد يكون العدد أكبر من صفر أو أصغر من صفر.
إذا كان العدد أكبر من صفر, يمسح bits من ناحية اليمين ثم يبدل كل bit منهم بصفر و يضعهم من ناحية اليسار.
		إذا كان العدد أصغر من صفر, يمسح bits من ناحية اليمين ثم يبدل كل bit منهم بواحد ليحافظ على إشارة الناقص و يضعهم من ناحية اليسار.
",,,,,"الحالة الأولى: إذا كان العدد أكبر من صفر.
","#include <iostream>
using namespace std;

int main()
{
    int a = 9;        // 9 = 00000000000000000000000000001001
    int c = a >> 2;   // شرحنا كيف سيتم الحصول على الناتج تحت نتيجة التشغيل
 
    cout << a << "" >> 2 = "" << c;

    return 0;
}
		","
9 >> 2 = 2
","a = 9;        // 9 = 00000000000000000000000000001001
c = a >> 2;   // c = 00000000000000000000000000000010
                  // c = 2
",,
العوامل,العوامل التي تستخدم للتعامل مع الـ Bits,العامل >> (Right Shift),,"العامل >> عندها حالتين: قد يكون العدد أكبر من صفر أو أصغر من صفر.
إذا كان العدد أكبر من صفر, يمسح bits من ناحية اليمين ثم يبدل كل bit منهم بصفر و يضعهم من ناحية اليسار.
		إذا كان العدد أصغر من صفر, يمسح bits من ناحية اليمين ثم يبدل كل bit منهم بواحد ليحافظ على إشارة الناقص و يضعهم من ناحية اليسار.
",,,,,"الحالة الثانية: إذا كان العدد أصغر من صفر.
","#include <iostream>
using namespace std;

int main()
{
    // Note "" >> "" converts the number in 32 bits form
 
    int a = -9;       // -9 = 11111111111111111111111111111000
    int c = a >> 2;   // شرحنا كيف سيتم الحصول على الناتج تحت نتيجة التشغيل
 
    cout << a <<  "" >> 2 = "" << c;

    return 0;
}
		","
-9 >> 2 = -3
","a = -9;       // -9 = 11111111111111111111111111110111
c = a >> 2;   //  c = 11111111111111111111111111111101
                  //  c = -3
",,
العوامل,العوامل التي تستخدم لإعطاء قيم للمتغيرات,العامل = (Basic Assign),,"العامل = يستخدم لإعطاء قيمة لمتغير.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
    int a = 10;
 
    cout << ""a = "" << a;

    return 0;
}
		","a = 10
",,,
العوامل,العوامل التي تستخدم لإعطاء قيم للمتغيرات,العامل += (Add and Assign),,"العامل += يستخدم لإضافة قيمة ما على قيمة المتغير بكود أقل.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
    int a = 10;
    int b = 20;
 
    a += b;        // a  =  a + b  =  10 + 20  =  30
 
    cout << ""a = "" << a;

    return 0;
}
		","a = 30
",,,
العوامل,العوامل التي تستخدم لإعطاء قيم للمتغيرات,العامل -= (Susbtract and Assign),,"العامل -= يستخدم لطرح قيمة ما من قيمة المتغير بكود أقل.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
    int a = 10;
    int b = 20;
 
    a -= b;           // a  =  a - b  =  10 - 20  =  -10
 
    cout << ""a = "" << a;

    return 0;
}
		","a = -10
",,,
العوامل,العوامل التي تستخدم لإعطاء قيم للمتغيرات,العامل *= (Multiply and Assign),,"العامل *= يستخدم لضرب قيمة المتغير بقيمة ما بكود أقل.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
    int a = 10;
    int b = 20;

    a *= b;   // a  =  a * b  =  10 * 20  =  200

    cout << ""a = "" << a;

    return 0;
}
		","a = 200
",,,
العوامل,العوامل التي تستخدم لإعطاء قيم للمتغيرات,العامل /= (Divide and Assign),,"العامل /= يستخدم لقسم قيمة المتغير على قيمة ما بكود أقل.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
    int a = 100;
    int b = 20;
 
    a /= b;   //   a  =  a / b  =  100 / 20  =  5
 
    cout << ""a = "" << a;

    return 0;
}
		","a = 5
",,,
العوامل,العوامل التي تستخدم لإعطاء قيم للمتغيرات,العامل %= (Modulo and Assign),,"العامل %= يستخدم لتخزين الباقي من قسمة قيمة المتغير على قيمة ما بكود أقل.

",,,,,,"#include <iostream>
using namespace std;

int main()
{
    int a = 10;
    int b = 7;
 
    a %= b;   //   a  =  a % b  =  10 % 7  =  3
 
    cout << ""a = "" << a;

    return 0;
}
		","a = 3
",,,
العوامل,العوامل التي تستخدم لإعطاء قيم للمتغيرات,العامل <<= (Left shift and Assign),,,,,,,"في المثال التالي, العامل <<= يعني إمسح bits من ناحية اليسار ثم بدل كل bit تم مسحها منهم بصفر و ضعهم من ناحية اليمين ثم ضع الناتج في المتغير من جديد.
","#include <iostream>
using namespace std;

int main()
{
    int a = 10;
    a <<= 2;   //   a  =  a << 2  =  00000000000000000000000000001010 << 2  =  00000000000000000000000000101000  =  40
 
    cout << ""a = "" << a;

    return 0;
}
		","a = 40
",,,
العوامل,العوامل التي تستخدم لإعطاء قيم للمتغيرات,العامل >>= (Right shift and Assign),,,,,,,"في المثال التالي, العامل >>= يعني إمسح bits من ناحية اليمين ثم بدل كل bit تم مسحها منهم بصفر و ضعهم من ناحية اليسار ثم ضع الناتج في المتغير من جديد.
","#include <iostream>
using namespace std;

int main()
{
	int a = 10;
    a >>= 2;   //   a  =  a >> 2  =  00000000000000000000000000001010 >> 2  =  00000000000000000000000000000010  =  2

    cout << ""a = "" << a;
	
    return 0;
}
		","a = 2
",,,
العوامل,العوامل التي تستخدم لإعطاء قيم للمتغيرات,العامل &= (Bitwise and Assign),,"العامل &= يعني أحسب ناتج جمع الـ bits المشتركة بين المتغير a و المتغير b ثم خزن الناتج في المتغير a.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
    int a = 10;
    int b = 75;
 
    a &= b;   //   a  =  a & b  =  00000000000000000000000000001010  &  00000000000000000000000001001011  =  00000000000000000000000000001010  =  10
 
    cout << ""a = "" << a;

    return 0;
}
		","a = 10
",,,
العوامل,العوامل التي تستخدم لإعطاء قيم للمتغيرات,العامل |= (Bitwise exclusive OR and Assign),,"العامل |= يعني أحسب ناتج جمع الـ bits المشتركة و الغير مشتركة بين المتغير a و المتغير b ثم خزن الناتج في المتغير a.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
    int a = 10;
    int b = 75;

    a |= b;   //   a  =  a | b  =  00000000000000000000000000001010  |  00000000000000000000000001001011  =  00000000000000000000000001001011  =  75

    cout << ""a = "" << a;

    return 0;
}
		","a = 75
",,,
العوامل,عوامل أخرى مهمة,العامل ?: (Conditional Operator),,"العامل ?: يقال له Conditional أو Ternary Operator لأنه يأخذ ثلاث عناصر ليعمل.
	يمكن إستعماله بدل جمل الشرط if و else في حال كنت تريد إعطاء قيمة للمتغير.
expression:   يمثل الشرط الذي نضعه.
	    value if true:   تمثل القيمة التي ستعطى للمتغير x إذا تحقق الشرط نضعها بعد الرمز ?.
	    value if false:   تمثل القيمة التي ستعطى للمتغير x إذا لم يتحقق الشرط نضعها بعد الرمز :.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
    int a = 10;
 
	// b إن لم تكن كذالك سيتم وضع القيمة 30 في المتغير ,b تساوي 1 سيتم وضع القيمة 20 في المتغير a إذا كانت قيمة المتغير
    int b = (a == 1) ?20 :30;
 
    cout << ""b = "" << b;

    return 0;
}
		","b = 30

",نلاحظ أنه تم وضع القيمة 30 في b لأن نتيجة الشرط كانت false.,,
العوامل,عوامل أخرى مهمة,العامل ?: (Conditional Operator),,"العامل ?: يقال له Conditional أو Ternary Operator لأنه يأخذ ثلاث عناصر ليعمل.
	يمكن إستعماله بدل جمل الشرط if و else في حال كنت تريد إعطاء قيمة للمتغير.
expression:   يمثل الشرط الذي نضعه.
	    value if true:   تمثل القيمة التي ستعطى للمتغير x إذا تحقق الشرط نضعها بعد الرمز ?.
	    value if false:   تمثل القيمة التي ستعطى للمتغير x إذا لم يتحقق الشرط نضعها بعد الرمز :.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
    int a = 10;
	
	// b إن لم تكن كذالك سيتم وضع القيمة 30 في المتغير ,b أكبر من 1 سيتم وضع القيمة 20 في المتغير a إذا كانت قيمة المتغير
    int b = (a > 1) ?20 :30;
 
    cout << ""b = "" << b;

    return 0;
}
		","b = 20

",نلاحظ أنه تم وضع القيمة 20 في b لأن نتيجة الشرط كانت true.,,
العوامل,عوامل أخرى مهمة,العامل sizeof() (Size Of Operator),,"يستخدم لمعرفة حجم المساحة المخصصة في الذاكرة لأي شيء يتم تمريره بين القوسين.
	الرقم الذي يتم إرجاعه يمثل الحجم بالـ Byte.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
	// C++ هنا قمنا بطباعة الحجم الذي يتطلبه كل نوع جاهز في لغة
    cout << ""Size of char: "" << sizeof(char) << endl;
    cout << ""Size of int: "" << sizeof(int) << endl;
    cout << ""Size of float: "" << sizeof(float) << endl;
    cout << ""Size of double: "" << sizeof(double) << endl;
    cout << ""Size of short int: "" << sizeof(short int) << endl;
    cout << ""Size of long int: "" << sizeof(long int) << endl;
    cout << ""Size of long long int: "" << sizeof(long long int) << endl;
    cout << ""Size of long double: "" << sizeof(long double) << endl;

    return 0;
}

		","Size of char: 1
Size of int: 4
Size of float: 4
Size of double: 8
Size of short int: 2
Size of long int: 4
Size of long long int: 8
Size of long double: 12
",,,
العوامل,عوامل أخرى مهمة,العامل sizeof() (Size Of Operator),,"يستخدم لمعرفة حجم المساحة المخصصة في الذاكرة لأي شيء يتم تمريره بين القوسين.
	الرقم الذي يتم إرجاعه يمثل الحجم بالـ Byte.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
	// int و نوعه x هنا قمنا بتعريف متغير إسمه
	int x = 5;
	
	// x هنا قمنا بطباعة الحجم الذي تم حجزه في الذاكرة من أجل المتغير
    cout << ""Size of x in memory: "" << sizeof(x) << "" Byte\n"";

    return 0;
}

		","Size of x in memory: 4 Byte
",,,
العوامل,عوامل أخرى مهمة,العامل & (Address),,"يستخدم لمعرفة عنوان المساحة المخصصة في الذاكرة للشيء الذي يتم وضعه بعده مباشرةً.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
	// int و نوعه x هنا قمنا بتعريف متغير إسمه
	int x = 5;
	
	// في الذاكرة x هنا قمنا بطباعة عنوان المساحة التي تم تخصيصها للمتغير
    cout << ""Address of x in memory: "" << &x;

    return 0;
}
		","Address of x in memory: 0x72feec
",,,
العوامل,عوامل أخرى مهمة,العامل * (Pointer),,"يستخدم لوضع مؤشر للشيء عند تعريفه مما يجعلك قادر على الوصول إليه بشكل مباشر من أي مكان تريد من خلال عنوانه في الذاكرة.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
	// 5 و قيمته x هنا قمنا بتعريف متغير إسمه
	int x = 5;
	
	// x و قمنا بتعريفه كمؤشر للمتغير y هنا قمنا بتعريف متغير إسمه
	// أصبحا يشيران لنفس القيمة المخزنة في الذاكرة y و المتغير x إذاً المتغير
    int *y = &x;

    // x و التي هي نفسها قيمة المتغير y هنا قمنا بطباعة القيمة الموضوعة في المتغير
    cout << ""y contain x value which is: "" << *y;

    return 0;
}
		","y contain x value which is: 5
",,,
العوامل,عوامل أخرى مهمة,"العامل , (Comma)",,"تستخدم الفاصلة لتنفيذ أكثر من عملية حسابية و من ثم إسناد قيمتها كلها في متغير واحد.
	مع الإشارة إلى أنه يجب وضع فاصلة بين كل عملتين تفوم بوضعهما.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
	// x هنا قمنا بتعريف متغير إسمه
	int x;
	
	// s تساوي 1, ثم أضفنا عليها 2, ثم ضربناها بالرقم 5. و في النهاية وضعنا الناتج في المتغير x هنا قمنا بجعل قيمة
	int s = (x = 1, x += 2, x *= 5);

	// s هنا قمنا بطباعة قيمة المتغير
    cout << ""s = ((1) + 2) * 5 = "" << s;

    return 0;
}
		","سنحصل على نتيجة تشبه النتيجة التالية عند التشغيل.
s = ((1) + 2) * 5 = 15
",,,
المتغيرات,مفهوم المتغيرات,مفهوم المتغيرات,,"المتغيرات ( variables ) عبارة عن أماكن يتم حجزها في الذاكرة بهدف تخزين بيانات فيها أثناء تشغيل البرنامج.
    النوع الذي نعطيه للمتغير يجعل نظام التشغيل يحدد نوع البيانات الذي يمكن تخزينه في المساحة المحجوزة لهذا المتغير في الذاكرة.
",,,,,,,,,,
المتغيرات,أساليب تعريف المتغيرات,أساليب تعريف المتغيرات,,"في البداية أنواع المتغيرات هي نفسها أنواع البيانات الأولية التي ذكرناها سابقاً و هي:
 int - float - double - bool - char
الآن, من خلال الأمثلة سنعلمك عدة أساليب يمكنك إتباعها لتعريف المتغيرات و تصغير حجم الكود.
في حال كنت تريد تعريف عدة متغيرات من نفس النوع و بدون إعطائهم قيم أولية.",,,,,"على سبيل المثال, إذا أردت تخزين رقم في متغير, يجب أن يكون نوع المتغير في الأساس مخصص لتخزين الأرقام حتى يسمح لك بذلك.
	و إذا أردت تخزين نص في المتغير يجب أن يكون نوع المتغير في الأساس مخصص لتخزين النصوص و هكذا.
","#include <iostream>
using namespace std;

int main()
{
	int a = 10;             // قيمته تساوي 10 a هنا قمنا بتعريف متغير إسمه
    cout << ""a = "" << a;    // a هنا قمنا بطباعة قيمة المتغير
	
    return 0;
}
		","a = 10
","
",,
المتغيرات,أساليب تعريف المتغيرات,المثال الأول,,"في حال كنت تريد تعريف عدة متغيرات من نفس النوع و بدون إعطائهم قيم أولية.
",,,"
	    تستطيع تعريفهم هكذا.
		int a;
int b;
int c;
		
	    و تستطيع إختصار الكود كالتالي.
		int a, b, c;
		
    ",,,,,,,
المتغيرات,أساليب تعريف المتغيرات,المثال الثاني,,"في حال كنت تريد تعريف عدة متغيرات من نفس النوع و إعطائهم قيم مباشرةً عند إنشائهم.
",,,"
	    تستطيع تعريفهم هكذا.
		int a = 10;
int b = 20;
int c = 30;
		
	    و تستطيع إختصار الكود كالتالي.
		int a=10, b=20, c=30;
		
    ",,,,,,,
المتغيرات,أساليب تعريف المتغيرات,المثال الثالث,,"في حال كنت تريد تعريف عدة متغيرات من نفس النوع و لكن طبيعتهم مختلفة و بدون قيم.
	هنا بالرغم من أن a عبارة عن متغير, b عبارة عن مصفوفة أحادية, و c عبارة عن مصفوفة ثنائية; إلَا أنهم جميعهم نوعهم int.
",,,"
	    تستطيع تعريفهم هكذا.
		int a;
int b[5];
int c[3][4];
		
	    و تستطيع إختصار الكود كالتالي.
		int a, b[5], c[3][4];
		
    ",,,,,,,
المتغيرات,مصطلحات مهمة حول المتغيرات,مصطلحات مهمة حول المتغيرات,,"ركز جيداً على المفاهيم التالية لكي تعرف كيف تصحح الأخطاء التي قد تتعرض لها عند كتابة الكود.
عملية تعريف متغير بدون إعطائه قيمة تسمى Declaration.
	    عملية إعطاء قيمة لمتغير تم إنشاؤه سابقاً تسمى Assigning.
	    عملية تعريف متغير و إعطائه قيمة مباشرةً عند إنشائه تسمى Initialisation.
","ملاحظة
إذا قمت بتعريف متغير بدون إعطائه أي قيمة, ثم حاولت طباعة قيمته فإن مترجم لغة C++ يقوم بإرجاع آخر قيمة كانت موجودة في الذاكرة مكان هذا المتغير.
إذاً هذا الأمر يحدث في حال حاولت طباعة قيمة متغير لم تفعل له سوى Declare.",,"
		هنا فعلنا Declare لمتغير جديد, أي قمنا بتعريف متغير جديد بدون إعطائه قيمة أولية.
	    int a;
		
		هنا فعلنا Assign لمتغير, أي قمنا بإعطاء قيمة لمتغير كان في الأصل موجوداً.
	    a = 10;
		
		هنا فعلنا Initialise لمتغير جديد, أي قمنا بإنشاء متغير جديد و إعطائه قيمة أولية.
	    double Sum = 0;
		
	",,,,,"
",,
المتغيرات,إرشادات مهمة لمعالجة الأخطاء,الخطأ الأول,,"أحياناً يقوم المبرمج بتعريف متغير و عرض قيمته قبل أن يعطيه أي قيمة فيظهر له قيم عشوائية فيه.
	أي المشكلة أنه حاول عرض قيمة متغير فعل له Declare فقط بدون أن يفعل له Assign.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
	int a;                  // بدون إعطائه أي قيمة أولية a هنا قمنا بتعريف متغير إسمه
    cout << ""a = "" << a;    // a هنا قمنا بطباعة قيمة المتغير
	
    return 0;
}
		","القيمة التي تظهر في المتغير a هي قيمة عشوائية كانت موجودة في الذاكرة كما ذكرنا قبل قليل.
a = 4360638","في برنامج CodeBlocks سيظهر لك التحذير التالي الذي يعني أنك تحاول طباعة قيمة متغير لا يملك قيمة في الأساس.
warning: 'a' is used uninitialized in this function [-Wuninitialized]
",,
المتغيرات,إرشادات مهمة لمعالجة الأخطاء,الخطأ الثاني,,"أحياناً يقوم المبرمج بوضع إسم متغير بدون أن يكون قد قام بتعريف هذا المتغير من قبل.
	أي المشكلة أنه نسيَ أن يفعل له Declare. من الأساس و هذا الأمر يؤدي لعدم تشغيل البرنامج كله.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
    cout << ""a = "" << a;    // مع أننا لم نقم بتعريفه بالأساس a هنا قمنا بطباعة قيمة
	
    return 0;
}
		","سيظهر لك الخطأ التالي عند التشغيل و الذي يعني أنك تحاول طباعة قيمة متغير لم تقم بتعريفه بالأساس.
error: 'a' was not declared in this scope
",,,
المتغيرات,إرشادات مهمة لمعالجة الأخطاء,الخطأ الثالث,,"كل نوع بيانات يمكنه أن يحتوي على قيم محددة حيث شاهدنا أصغر و أكبر قيمة يمكن تخزينها فيه.
الأن عليك معرفة أنه في حال كانت القيمة التي تحاول تخزينها في المتغير أكبر من القيمة التي يمكن تخزينها فيه, سيتم وضع جزء منها في المتغير و ليس القيمة التي كنت تريد تخزينها فيه و بالتالي ستخسر القيمة الحقيقية التي كنت تريد تخزينها. هذا الأمر يجب أن تنتبه له جيداً حتى تخزّن البيانات بشكل صحيح بدون فقدان أي جزء منها.
الآن, بما أن النوع int يمكنه أن يخزن القيمة 2147483647 كحد أقصى, لاحظ ما سيحدث إن حاولنا تخزين قيمة أكبر من القيمة القصوى التي يمكن أن يستوعبها فيه.
",,,,,,"#include <iostream>
using namespace std;

int main()
{
	int a = 10000000000000;     // و نحن ندرك أنه لا يمكن تخزين هذه القيمة الكبيرة فيه a هنا قمنا بوضع قيمة في المتغير
    cout << ""a = "" << a;
	
    return 0;
}
		","القيمة التي تظهر في المتغير a هي جزء من القيمة التي كنت تحاول تخزينها في المتغير كما ذكرنا قبل قليل.
a = 1316134912


","في برنامج CodeBlocks سيظهر لك التحذير [Overflow] الذي يعني أن المساحة المخصصة للمتغير في الذاكرة لا يمكنها أن تستوعب القيمة التي تحاول تخزينها فيه.
warning: overflow in implicit constant conversion [-Woverflow]",,
المصفوفات,تعريف مصفوفة,تعريف مصفوفة,,"هناك ثلاث طرق يمكنك اتباعها لتعريف مصفوفة (Declare Array) جديدة سنتعرف عليها تباعاً.

	    
		    // الأسلوب التالي يستخدم لتعريف مصفوفة مع تحديد عدد عناصرها
		    datatype arrayName[size];
		    // الأسلوب التالي يستخدم لتعريف مصفوفة مع تحديد قيمها الأولية
		    datatype arrayName[] = {value1, value2, ..};
		    // الأسلوب التالي يستخدم لتعريف مصفوفة مع تحديد عدد عناصرها و قيمة بعض عناصرها
		    datatype arrayName[size] = {value1, value2, ..};
	    
	


	    datatype: هو نوع القيم التي يمكن تخزينها في عناصر المصفوفة.
	    size: هو عدد عناصر المصفوفة.
	    arrayName: هو إسم المصفوفة.
	    []: هذا الرمز يمثل من كم بعد تتألف المصفوفة.
	


",,,"
	    أمثلة
		// و تتألف من 5 عناصر int نوعها ,arr هنا قمنا بتعريف مصفوفة ذات بعد واحد إسمها
int arr[5];

// و وضعنا فيها 6 عناصر, و هذا يعني أن عدد عناصرها أصبح 6 لأننا لم نحدد عدد عناصرها int نوعها ,arr هنا قمنا بتعريف مصفوفة ذات بعد واحد إسمها
int arr[] = {1, 2, 3, 4, 5, 6};

// و تتألف من 5 عناصر, و قمنا بوضع قيم أولية في أول 3 عناصر فيها int نوعها ,arr هنا قمنا بتعريف مصفوفة ذات بعد واحد إسمها
int arr[5] = {1, 2, 3};
		
	","أمثلة حول طريقة تعريف مصفوفة أحادية ( One Dimensional Array ).
",,,,,,
المصفوفات,تعريف مصفوفة,تعريف مصفوفة,,,,,"
	    أمثلة
		// و تتألف من 3 × 4 عناصر int نوعها ,arr هنا قمنا بتعريف مصفوفة ذات بعدين إسمها
int arr[4][3];

// وضعنا فيها مصفوفتين تتألف كل واحدة منهما من 3 عناصر, هذا يعني أن المصفوفة تتألف من 2 × 3 عناصر int نوعها ,arr هنا قمنا بتعريف مصفوفة ذات بعدين إسمها
int arr[][] = {
		{1, 2, 3},
		{4, 5, 6}
	};

// و تتألف من 3 × 4 عناصر, وقمنا بوضع 6 قيم أولية فيها int نوعها ,arr هنا قمنا بتعريف مصفوفة ذات بعدين إسمها
int arr[4][3] = {
		{1, 2, 3},
		{4, 5, 6}
	};
		
	","
أمثلة حول طريقة تعريف مصفوفة ثنائية ( Two Dimensional Array ).",,,,,,
المصفوفات,الوصول لعناصر المصفوفة,الوصول لعناصر المصفوفة,,"لنفترض الآن أننا قمنا بتعريف مصفوفة نوعها int, إسمها a, و تتألف من 5 عناصر.
int a[] = { 10, 20, 30, 40, 50 };
يمكنك تصور شكل المصفوفة a في الذاكرة كالتالي.

بما أن المصفوفة تتألف من 5 عناصر, تم إعطاء العناصر أرقام indexes بالترتيب من 0 إلى 4.
إذاً هنا أصبح عدد عناصر المصفوفة يساوي 5 و هو ثابت لا يمكن تغييره لاحقاً في الكود.
	و للوصول لقيمة أي عنصر نستخدم index العنصر الذي تم إعطاؤه له.
",,,,,"في المثال التالي, قمنا بتعريف مصفوفة, ثم غيرنا قيمة العنصر الأول فيها, و من ثم عرضنا قيمة جميع العناصر.
","#include <iostream>

using namespace std;

int main()
{
	// هنا قمنا بتعريف مصفوفة تتألف من 5 عناصر
    int arr[] = {10, 20, 30, 40, 50};
	
	// هنا قمنا بتغيير قيمة العنصر الأول و العنصر الأخير في المصفوفة
	arr[0] = 1;
	arr[4] = 5;
	
	// هنا قمنا بعرض قيم جميع عناصر المصفوفة
    cout << ""arr[0] = "" << arr[0] << endl;
    cout << ""arr[1] = "" << arr[1] << endl;
    cout << ""arr[2] = "" << arr[2] << endl;
    cout << ""arr[3] = "" << arr[3] << endl;
    cout << ""arr[4] = "" << arr[4] << endl;

    return 0;
}
		","arr[0] = 1
arr[1] = 20
arr[2] = 30
arr[3] = 40
arr[4] = 5
",,,
المصفوفات,وضع قيم أولية لعناصر المصفوفة,وضع قيم أولية لعناصر المصفوفة,,"إذا قمت بإنشاء مصفوفة جديدة مع تحديد عدد عناصرها فقط و بدون إعطائها قيم أولية, من المحتمل أن تجد قيم غريبة في بعض عناصرها.
	سبب ذلك أن هذه القيم كانت موجودة مسبقاً في الذاكرة لا أكثر.
لذا في حال أردت إنشاء مصفوفة جديدة مع حذف أي قيم إفتراضية قد تكون موجودة فيها, يجب أن تقوم بتمرير القيمة الإفتراضية التي تريد وضعها لعناصر المصفوفة لحظة إنشائها.
",,,,,"في المثال التالي, قمنا بتعريف مصفوفة تتألف من 5 عناصر و لم نعطها قيم أولية, ثم قمنا بعرض القيم الإفتراضية الموجودة فيها.
","#include <iostream>

using namespace std;

int main()
{
	// هنا قمنا بتعريف مصفوفة تتألف من 5 عناصر
    int arr[5];
	
	// هنا قمنا بعرض القيم الإفتراضية الموجودة في عناصر المصفوفة
    cout << ""arr[0] = "" << arr[0] << endl;
    cout << ""arr[1] = "" << arr[1] << endl;
    cout << ""arr[2] = "" << arr[2] << endl;
    cout << ""arr[3] = "" << arr[3] << endl;
    cout << ""arr[4] = "" << arr[4] << endl;

    return 0;
}
		","عند تشغيل البرنامج حصلنا على نتيجة غريبة حيث وجدنا قيم إفتراضية في بعض العناصر.
arr[0] = 8
arr[1] = 0
arr[2] = 42
arr[3] = 0
arr[4] = 15275776

",ملاحظة: من الطبيعي أن لا تظهر لك نفس النتيجة التي ظهرت لنا لأن هذه القيم هي قيم عشوائية.,,
المصفوفات,وضع قيم أولية لعناصر المصفوفة,وضع قيم أولية لعناصر المصفوفة,المثال الثاني,,,,,,"في المثال التالي قمنا بوضع القيمة 0 كقيمة أولية لجميع عناصر المصفوفة, ثم قمنا بعرض قيمها.
","#include <iostream>

using namespace std;

int main()
{
	// هنا قمنا بتعريف مصفوفة تتألف من 5 عناصر مع تحديد أن القيمة الإفتراضية في جميع عناصرها هي 0
    int arr[5] = {0};
	
	// هنا قمنا بعرض القيم الإفتراضية الموجودة في عناصر المصفوفة
    cout << ""arr[0] = "" << arr[0] << endl;
    cout << ""arr[1] = "" << arr[1] << endl;
    cout << ""arr[2] = "" << arr[2] << endl;
    cout << ""arr[3] = "" << arr[3] << endl;
    cout << ""arr[4] = "" << arr[4] << endl;

    return 0;
}
		","arr[0] = 0
arr[1] = 0
arr[2] = 0
arr[3] = 0
arr[4] = 0
",,,
المصفوفات,معرفة عدد عناصر المصفوفة,معرفة عدد عناصر المصفوفة,,"إذا أردت معرفة عدد عناصر أي مصفوفة, يمكنك الحصول عليه من خلال قسمة حجم المصفوفة, على نوع العناصر المخزنة فيها.
",,,,,,"#include <iostream>

using namespace std;

int main()
{
	// هنا قمنا بتعريف مصفوفة تتألف من 5 عناصر حيث وضعنا فيها 5 قيم رقمية و كل قيمة سيتم وضعها في عنصر
    int arr[] = {1, 2, 3, 4, 5};
	
	// n على حجم نوع أول عنصر فيها, و من ثم قمنا بتخزين الناتج في المتغير arr هنا قمنا بقسمة عدد عناصر المصفوفة
	int n = sizeof(arr) / sizeof(arr[0]);
	
	// n الذي قمنا بتخزينه في المتغير arr هنا قمنا بطباعة عدد عناصر المصفوفة
    cout << ""Number of elements in the array is: "" << n;

    return 0;
}
		","Number of elements in the array is: 5
",,,
المصفوفات,التعامل مع المصفوفة بواسطة حلقة,التعامل مع المصفوفة بواسطة حلقة,,"عند التعامل مع المصفوفات فإنك على الأغلب ستستخدم حلقة للمرور على قيمها سواء للبحث عن قيمة فيها, تحديث قيمها, أو لمجرد طباعة القيم الموجودة فيها.
",,,,,"في المثال التالي إفترضنا أن عدد عناصر المصفوفة التي سنعرض قيمها معروف.
","#include <iostream>

using namespace std;

int main()
{
	// هنا قمنا بإنشاء مصفوفة تحتوي على 3 قيم نصية
    string fruits[3] = {""Apple"", ""Banana"", ""Orange""};

	// على سطر جديد fruits هنا قمنا بإنشاء حلقة, في كل دورة تقوم بعرض قيمة من القيم الموجودة في المصفوفة
    for (int i=0; i<3; i++)
    {
        cout << fruits[i] << endl;
    }

    return 0;
}
		","Apple
Banana
Orange
",,,
المصفوفات,التعامل مع المصفوفة بواسطة حلقة,التعامل مع المصفوفة بواسطة حلقة,,"عند التعامل مع المصفوفات فإنك على الأغلب ستستخدم حلقة للمرور على قيمها سواء للبحث عن قيمة فيها, تحديث قيمها, أو لمجرد طباعة القيم الموجودة فيها.
",,,,,"في المثال التالي إفترضنا أن عدد عناصر المصفوفة التي سنعرض قيمها غير معروف.
","#include <iostream>

using namespace std;

int main()
{
	// هنا قمنا بإنشاء مصفوفة تحتوي على 3 قيم نصية
    string fruits[] = {""Apple"", ""Banana"", ""Orange""};
	
	// n و من ثم تخزينه في المتغير fruits هنا قمنا بحساب عدد عناصر المصفوفة
	int n = sizeof(fruits) / sizeof(fruits[0]);

	// على سطر جديد fruits هنا قمنا بإنشاء حلقة, في كل دورة تقوم بعرض قيمة من القيم الموجودة في المصفوفة
    for (int i=0; i<n; i++)
    {
        cout << fruits[i] << endl;
    }

    return 0;
}
		","Apple
Banana
Orange
",,,
المصفوفات,الحلقة foreach,الحلقة foreach,,"إبتداءاً من إصدار المترجم C++ 11 تم إضافة حلقة for جديدة إسمها Foreach Loop.
	هذه الحلقة تسمح لك بالمرور على جميع عناصر المصفوفة دون الحاجة لتعريف عداد و تحديد أين يبدأ و أين ينتهي.
طريقة تعريف الحلقة Foreach
for (element: array)
			{
			    // statements
			}
element: هو متغير عادي نقوم بتعريفه بداخل الحلقة و نعطيه نفس نوع المصفوفة التي نضعها بعد النقطتين, لأنه في كل دورة سيقوم بتخزين قيمة عنصر من عناصرها, لذلك يجب جعل نوعه مثل نوعها.
		array: هي المصفوفة التي نريد الوصول لجميع عناصرها.
	    statements: هي جميع الأوامر الموضوعة في الحلقة و هي تتنفذ في كل دورة.
إذاً هنا تقوم الحلقة بالمرور على جميع عناصر المصفوفة بالترتيب من العنصر الأول إلى العنصر الأخير, و في كل دورة تقوم بتخزين قيمة العنصر في المتغير الذي قمنا بتعريفه.
سنقوم الآن بكتابة برنامج بسيط يعرض قيم جميع عناصر مصفوفة باستخدام الحلقة Foreach.
",,,,,,"#include <iostream>

using namespace std;

int main()
{
	// هنا قمنا بإنشاء مصفوفة تحتوي على 3 قيم نصية
    string fruits[] = {""Apple"", ""Banana"", ""Orange""};
	
	// element في المتغير fruits هنا في كل دورة سيتم تخزين قيمة عنصر من عناصر المصفوفة
    for (string element: fruits)
    {
		// element هنا سيتم عرض القيمة التي تخزنت في المتغير
        cout << element << endl;
    }

    return 0;
}
		","Apple
Banana
Orange
",,,
أنواع البيانات,مفهوم أنواع البيانات,مفهوم أنواع البيانات,,"أي شيء تتعامل معه في C++ له نوع محدد و له طريقة خاصة للتعامل معه فيها; فمثلاً الأرقام لها طريقة للتعامل معها, النصوص لها طريقة للتعامل معها, الدوال لها طريقة للتعامل معها و هكذا.
في C++ يوجد أنواع بيانات بسيطة و جاهزة يمكنك التعامل معها سنطلعك عليها في هذا الدرس, و يوجد أنواع أخرى جاهزة ستتعلمها لاحقاً في الدورة لأنك غير مستعد لها بعد, كما تستطيع تعريف أنواع جديدة و هذا الأمر ستتعلمه لاحقاً أيضاً.

البيانات في C++ تنقسم لثلاث أقسام رئيسية:
1. نوع البيانات الأولية أو المدمجة أو الأساسية
2. أنواع البيانات المشتقة
3. أنواع البيانات التي يحددها المستخدم
أنواع البيانات الأساسية التي سنتعرف عليها و سنبدأ بالتعامل معها من الآن هي الأنواع الأولية ( Primary ) و التي تعتبر نفسها في أغلب لغات البرمجة.


	
","ملاحظة

  قد تجد مسميات أخرى تطلق على أنواع البيانات و هذا شيء طبيعي جداً, فمثلاً قد تجد أنواع البيانات الأولية ( Primary ) يقال لها أنواع بدائية ( Basic Data type ) أو أنواع تأتي ضمن اللغة مباشرةً ( Built-in ) و غير ذلك و لكن الفكرة هي نفسها و هذه كلها إختلافات غير مهمة على الإطلاق.",,,,,,,,,
أنواع البيانات,أنواع البيانات الأولية,أنواع البيانات الأولية,,"أهم أنواع البيانات الأولية في C++ و أكثرها استخداماً هي:
int - float - double - bool - char",,,,,,,,,,
أنواع البيانات,أنواع البيانات الأولية,النوع int,,"يستخدم هذا النوع لتخزين عدد صحيح, أي عدد لا يحتوي على فاصلة عشرية.
",,,"
     مثال
     int x = 10;
  ",,,"	",,"
",,
أنواع البيانات,أنواع البيانات الأولية,النوع float,,"يستخدم هذا النوع لتخزين عدد يمكن أن يحتوي على فاصلة عشرية.
	يمكن لهذا العدد أن يحتوي على 7 أرقام بعد الفاصلة.
",,,"
	    مثال
	    float x = 12.5;
		
	",,,"
		
	",,,,
أنواع البيانات,أنواع البيانات الأولية,النوع double,,"يستخدم هذا النوع لتخزين عدد يمكن أن يحتوي على فاصلة عشرية.
	يمكن لهذا العدد أن يحتوي على 15 رقم بعد الفاصلة لهذا يعتبر أكثر دقة من النوع float في العمليات الحسابية الدقيقة.
",,,"
	    مثال
	    double x = 12.5;
		
	",,,,,,,
أنواع البيانات,أنواع البيانات الأولية,النوع bool,,"يستخدم هذا النوع لتخزين إما القيمة true و إما القيمة false.
",,,"
	    مثال
	    bool x = true;
		
	",,,,,,,
أنواع البيانات,أنواع البيانات الأولية,النوع char,,"يستخدم هذا النوع لتخزين حرف أجنبي أو لتخزين عدد صحيح قيمته تمثل حرف نسبةً لرقم الآسكي كود ( ASCII Code ) الخاص به.
	فمثلاً char x = 65; نفسها تماماً إن كتبت  char x = 'A';.
	سبب تحول الرقم 65 إلى الحرف 'A' في الذاكرة هو أنه في نظام ASCII الرقم 65 يمثل الحرف 'A'.
ملاحظة: النوع char يمكنه تخزين أي حرف أجنبي بدون مشاكل لأن الحرف الأجنبي يحتاج مساحة 1Byte من الذاكرة فقط حتى يتم تخزينه.
بينما الحرف العربي يحتاج مساحة 2Bytes من الذاكرة حتى يتم تخزينه بشكل صحيح.

لهذا السبب, عند التعامل مع الأحرف العربية يستحسن تخزين الحرف الواحد كمصفوفة نوعها char تتألف من عنصرين أو كنص عادي نوعه string.
لا داعي للقلق بشأن تخزين الأحرف العريبة لأن ما ذكرناه الآن سيمر معك في دروس لاحقة.",,,"
	    مثال
	    char x = 'A';
		
	",,,,,"
",,
أنواع البيانات,خصائص أنواع البيانات,تحديد خصائص أنواع البيانات,,"في C++ يوجد مجموعة كلمات يقال لها Data Type Modifiers يمكنك استخدامها لتحديد خصائص القيم التي يمكن تخزينها, مثل هي يمكن أن تكون قيم أصغر من صفر أم لا, بالإضافة إلى تكبير حجم المساحة التي يتم تخصيصها لكل نوع في الذاكرة مما يجعلك قادر على تخزين قيم أكبر.
الأنواع char و int و double يمكن تحديد خصائص القيم التي يمكن تخزينها فيها إذا أضفنا معها إحدى الكلمات التالية:

		signed نضيفها لأحد الأنواع السابقة إذا أردنا تحديد أن قيمة المتغير لا يهم إن كانت أكبر, أصغر أو تساوي صفر.
		unsigned نضيفها لأحد الأنواع السابقة إذا أردنا تحديد أن قيمة المتغير لا يمكن أن تكون أصغر من صفر.
		short نضيفها لأحد الأنواع السابقة إذا أردنا تحديد أن حجم الذاكرة التي سيتم تخصيصها للمتغير هو 2Byte.
		long نضيفها لأحد الأنواع السابقة إذا أردنا تحديد أن حجم الذاكرة التي سيتم تخصيصها للمتغير هو 8Byte.","معلومة تقنية
إفتراضياً الأنواع char - int - float - double جميعا تعتبر signed حتى لو لم تحدد ذلك بنفسك لهذا السبب تستطيع تخزين قيم أصغر من صفر فيها.",,,,,,,,,
أنواع البيانات,خصائص أنواع البيانات,خصائص أنواع البيانات,,الجدول التالي يوضح المساحة التي يحتاجها كل نوع في الذاكرة و القيم التي يمكن تخزينها فيه سواء تم استخدام النوع لوحده أو تم تحديد خصائصه.,,"['char\n      1Byte\n   بين -128 و 127', 'unsigned char\n      1Byte\n   بين 0 و 255', 'short int\n      2Bytes\n   بين -32768 و 32767', 'unsigned short int\n      2Bytes\n   بين 0 و 65535', 'int\n      4Bytes\n   بين -2147483648 و 2147483647', 'unsigned int\n      4Bytes\n   بين 0 و 4294967295', 'long int\n      4Bytes\n   بين -2147483648 و 2147483647', 'unsigned long int\n      4Bytes\n   بين 0 و 4294967295', 'long long int\n      8Bytes\n   بين -9223372036854775808 و 9223372036854775807', 'unsigned long long int\n      8Bytes\n   بين 0 و 18446744073709551615', 'float\n      4Bytes\n   بين 1.17549e-038 و 3.40282e+038', 'double\n      8Bytes\n   بين 2.22507e-308 و 1.79769e+308', 'long double\n      12Bytes\n   بين 3.3621e-4932 و 1.18973e+4932\n']",,"  
","  
",,,,,
أنواع البيانات,خصائص أنواع البيانات,خصائص أنواع البيانات,,,,,"
	    مثال
	    // short int هنا استخدامنا النوع
short int x = 4545;

// long long int هنا استخدامنا النوع
long long int y = -50050012;

// unsigned long int هنا استخدامنا النوع
unsigned long int = 880045023;
		
	",في حال أردت استخدام أي نوع مع تحديده خصائصه فيمكنك استخدام أي نوع تم ذكره في الجدول كالتالي.,,,,,,
